{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prototyping Documentation This documentations intention is to get a depth sight into everything discoverd while playing around with Arduinos, other microcontrollers and IoT Cloud Systems. For prototyping purposes a PlatformIO project has been created. The repository can be cloned by using the following link https://github.com/ECE-IoT/Prototyping.git Here is the: Prototyping Guide which helps to set up everything correctly. When everything is configured as shown, the documentation of the prototyping phase should be easy and intuitive. Warning The repository does NOT sync the code in main.cpp . Thats due to the fact that every developer is using their own code in the main.cpp and this would cause a merge mess. If you are cloning the repository the first time, please add a new main.cpp file to your file-tree /src","title":"Home"},{"location":"#prototyping-documentation","text":"This documentations intention is to get a depth sight into everything discoverd while playing around with Arduinos, other microcontrollers and IoT Cloud Systems. For prototyping purposes a PlatformIO project has been created. The repository can be cloned by using the following link https://github.com/ECE-IoT/Prototyping.git Here is the: Prototyping Guide which helps to set up everything correctly. When everything is configured as shown, the documentation of the prototyping phase should be easy and intuitive. Warning The repository does NOT sync the code in main.cpp . Thats due to the fact that every developer is using their own code in the main.cpp and this would cause a merge mess. If you are cloning the repository the first time, please add a new main.cpp file to your file-tree /src","title":"Prototyping Documentation"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/","text":"Arduino IoT Cloud compatible boards Compatibel Arduino boards Currently (11/10/2021) the 9 official Arduino boards described below are compatible. Additionally many 3 rd party boards based on the ESP32 / ESP8266 are also compatible. MKR Wifi 1010 Connectivity: Wifi Special functions: Li-Po charging circuit, ECC508 crypto chip MKR Wifi 1000 Connectivity: Wifi, BLE Special functions: Li-Po charging circuit, ECC508 crypto chip Nano 33 IoT Connectivity: Wifi, BLE Special functions: IMU , ECC508 crypto chip, Cheapest Board! MKR WAN 1300 Connectivity: LoRa Special functions: low power consumption MKR WAN 1310 Connectivity: LoRa Special functions: low power consumption, ECC508 crypto chip MKR GSM 1400 Connectivity: GSM / 3G Special functions: Li-Po charging circuit, ECC508 crypto chip MKR NB 1500 Connectivity: NB LTE Special functions: low power consumption, Li-Po charging circuit, ECC508 crypto chip Nano RP2040 Connect Connectivity: Wifi, BLE Special functions: based on the Raspberry Pi RP2040, Microphone, IMU , ECC608 crypto chip, Micropyhton support Portenta H7 Connectivity: Wifi, BLE, Ethernet, Displayport output over USB-C Special functions: on board GPU, Li-Po charging circuit, generally for high level code with realtime taks, NXP SE050C2 crypto chip, Micropyhton support Compatible Linux devices The following Linux devices are supported: Arduino Pro Gateway Intel\u00ae-based platforms IEI TANK AIoT Dev Kit Arm\u00ae-based platforms Raspberry Pi BeagleBone UP Squared AI Vision Kit UP Squared Grove IoT Development Kit More Information Overview of supportet devices About python on the Arduino. About Low-Power Wan. About to setup up a Linux device Source of information This description ist mainly based on the linked websites and further information to the boards can also be found there.","title":"Compatible boards"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/#arduino-iot-cloud-compatible-boards","text":"","title":"Arduino IoT Cloud compatible boards"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/#compatibel-arduino-boards","text":"Currently (11/10/2021) the 9 official Arduino boards described below are compatible. Additionally many 3 rd party boards based on the ESP32 / ESP8266 are also compatible. MKR Wifi 1010 Connectivity: Wifi Special functions: Li-Po charging circuit, ECC508 crypto chip MKR Wifi 1000 Connectivity: Wifi, BLE Special functions: Li-Po charging circuit, ECC508 crypto chip Nano 33 IoT Connectivity: Wifi, BLE Special functions: IMU , ECC508 crypto chip, Cheapest Board! MKR WAN 1300 Connectivity: LoRa Special functions: low power consumption MKR WAN 1310 Connectivity: LoRa Special functions: low power consumption, ECC508 crypto chip MKR GSM 1400 Connectivity: GSM / 3G Special functions: Li-Po charging circuit, ECC508 crypto chip MKR NB 1500 Connectivity: NB LTE Special functions: low power consumption, Li-Po charging circuit, ECC508 crypto chip Nano RP2040 Connect Connectivity: Wifi, BLE Special functions: based on the Raspberry Pi RP2040, Microphone, IMU , ECC608 crypto chip, Micropyhton support Portenta H7 Connectivity: Wifi, BLE, Ethernet, Displayport output over USB-C Special functions: on board GPU, Li-Po charging circuit, generally for high level code with realtime taks, NXP SE050C2 crypto chip, Micropyhton support","title":"Compatibel Arduino boards"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/#compatible-linux-devices","text":"The following Linux devices are supported: Arduino Pro Gateway Intel\u00ae-based platforms IEI TANK AIoT Dev Kit Arm\u00ae-based platforms Raspberry Pi BeagleBone UP Squared AI Vision Kit UP Squared Grove IoT Development Kit","title":"Compatible Linux devices"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/#more-information","text":"Overview of supportet devices About python on the Arduino. About Low-Power Wan. About to setup up a Linux device","title":"More Information"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/#source-of-information","text":"This description ist mainly based on the linked websites and further information to the boards can also be found there.","title":"Source of information"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/","text":"Arduino IoT Cloud example About the example. The goal of this application is to measure temperature and humidity with an Arduino mkr 1010 board, periodically transfer the measured values to the cloud and display them on a dashboard. There is also an LED connected to the Arduino that can be turned on and off with a button on the dashboard. Implementation Config at AIC I created an thing named example_aplication . The thing contains three variables. Two float read only variables (mkr1010_humid and mkr1010_temp) to get temperature and humidity values. These two variables are automatically updated to the cloud every second. The thrid variable is a bool read and write variable (mkr1010_led). It is used to control the connected LED and is updated when the variable is changed on the device or in the AIC. Furthermore, the device (Arduino mkr 1010) had to be added and the network information had to be specified. Generated Sketch All configuration was done on the AIC website and the sketch file was created automatically. I downloaded the sketch and edited it witch PlatformIO. Steps involved to do that are described here . Besides the main code wiht a setup() and void() the sketch also includes the files thingProperties.h and arduino_secrets.h. thingProperties.h In that generated file is the configuration for the created variables and the wifi connection. I removed the thing id, but you cant find it in the sharpoint fodler under \"Dateien\\Administration\\Arduino IoT Cloud\\Wifi and thing id.txt\" #include \"ArduinoIoTCloud.h\" #include \"Arduino_ConnectionHandler.h\" #include \"arduino_secrets.h\" const char THING_ID[] = \"enter thing ID\"; const char SSID[] = SECRET_SSID; // Network SSID (name) const char PASS[] = SECRET_PASS; // Network password (use for WPA, or use as key for WEP) void onMkr1010LedChange(); float mkr1010_humid; bool mkr1010_led; float mkr1010_temp; void initProperties() { ArduinoCloud.setThingId(THING_ID); ArduinoCloud.addProperty(mkr1010_humid, READ, 1 * SECONDS, NULL); ArduinoCloud.addProperty(mkr1010_led, READWRITE, ON_CHANGE, onMkr1010LedChange); ArduinoCloud.addProperty(mkr1010_temp, READ, 1 * SECONDS, NULL); } WiFiConnectionHandler ArduinoIoTPreferredConnection(SSID, PASS); arduino_secrets.h This file cotains the network information. At the Fh we can use the ECEmbedded network. The related information can be found in the sharpoint fodler under \"Dateien\\Administration\\Arduino IoT Cloud\\Wifi and thing id.txt\" #define SECRET_SSID \"enter ssid\" #define SECRET_PASS \"enter password\" main Originally a main was created with the following structure. #include <Arduino.h> #include \"arduino_secrets.h\" #include \"thingProperties.h\" setup() { // Initialize serial and wait for port to open: Serial.begin(9600); // This delay gives the chance to wait for a Serial Monitor without blocking if none is found delay(1500); // Defined in thingProperties.h initProperties(); // Connect to Arduino IoT Cloud ArduinoCloud.begin(ArduinoIoTPreferredConnection); /* The following function allows you to obtain more information related to the state of network and IoT Cloud connection and errors the higher number the more granular information you\u2019ll get. The default is 0 (only errors). Maximum is 4 */ setDebugMessageLevel(2); ArduinoCloud.printDebugInfo(); } loop() { ArduinoCloud.update(); } void onMkr1010LedChange() { } Most of the code is self-explanatory. The function ArduinoCloud.update(); is used to reset the Watchdogtimer frequently. The purpose of the Watchdog is to restart the arduino when it does not work corectly. To detect this the watchdog counts down from a certain number and when zero is reached it detects an error and resets the arduino. Therefore the timer must be reset often. The function onMkr1010LedChange() is called from the AIC when a value change of the mkr1010_led variable happend. Implementation of the measurement and the LED. The code to measure temperature and humidity and the sensor is described here . This code is used in the main. An example how to controll an LED can be found here . More changes I have adapted the main of the example so that by inserting the functions example_setup() example_loop() the program is executed. You can add the following code to your main.cpp in the src folder and it should work. #include <arduino.h> #include \"aic_example/example_main.hpp\" void setup() { example_setup(); } void loop() { example_loop(); } Necessary libraries ArduinoIoTCloud.h Arduino_ConnectionHandler.h Adafruit_Sensor.h DHT.h Add the following code to your libraries, if not already present. lib_deps = adafruit/DHT sensor library@^1.4.2 adafruit/Adafruit Unified Sensor@^1.1.4 arduino-libraries/ArduinoIoTCloud@^1.2.1 arduino-libraries/Arduino_ConnectionHandler@^0.6.4 How to connect the sensor and the LED In the example the LED is vonnect at pin 1 and the data output of the DHT11 is connected to pin 0. I used a 220 Ohm resistor for the LED circuit. Dashboard On the aic website, under dashboards, you will find a large number of widgets that you can simply click together and connect to the variables. I have clicked a few together. This dashboard can be viewed on the website or in the AIC app. More information More information (e.g. login to AIC, getting started with AIC) can be found here .","title":"Example"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#arduino-iot-cloud-example","text":"","title":"Arduino IoT Cloud example"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#about-the-example","text":"The goal of this application is to measure temperature and humidity with an Arduino mkr 1010 board, periodically transfer the measured values to the cloud and display them on a dashboard. There is also an LED connected to the Arduino that can be turned on and off with a button on the dashboard.","title":"About the example."},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#implementation","text":"","title":"Implementation"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#config-at-aic","text":"I created an thing named example_aplication . The thing contains three variables. Two float read only variables (mkr1010_humid and mkr1010_temp) to get temperature and humidity values. These two variables are automatically updated to the cloud every second. The thrid variable is a bool read and write variable (mkr1010_led). It is used to control the connected LED and is updated when the variable is changed on the device or in the AIC. Furthermore, the device (Arduino mkr 1010) had to be added and the network information had to be specified.","title":"Config at AIC"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#generated-sketch","text":"All configuration was done on the AIC website and the sketch file was created automatically. I downloaded the sketch and edited it witch PlatformIO. Steps involved to do that are described here . Besides the main code wiht a setup() and void() the sketch also includes the files thingProperties.h and arduino_secrets.h. thingProperties.h In that generated file is the configuration for the created variables and the wifi connection. I removed the thing id, but you cant find it in the sharpoint fodler under \"Dateien\\Administration\\Arduino IoT Cloud\\Wifi and thing id.txt\" #include \"ArduinoIoTCloud.h\" #include \"Arduino_ConnectionHandler.h\" #include \"arduino_secrets.h\" const char THING_ID[] = \"enter thing ID\"; const char SSID[] = SECRET_SSID; // Network SSID (name) const char PASS[] = SECRET_PASS; // Network password (use for WPA, or use as key for WEP) void onMkr1010LedChange(); float mkr1010_humid; bool mkr1010_led; float mkr1010_temp; void initProperties() { ArduinoCloud.setThingId(THING_ID); ArduinoCloud.addProperty(mkr1010_humid, READ, 1 * SECONDS, NULL); ArduinoCloud.addProperty(mkr1010_led, READWRITE, ON_CHANGE, onMkr1010LedChange); ArduinoCloud.addProperty(mkr1010_temp, READ, 1 * SECONDS, NULL); } WiFiConnectionHandler ArduinoIoTPreferredConnection(SSID, PASS); arduino_secrets.h This file cotains the network information. At the Fh we can use the ECEmbedded network. The related information can be found in the sharpoint fodler under \"Dateien\\Administration\\Arduino IoT Cloud\\Wifi and thing id.txt\" #define SECRET_SSID \"enter ssid\" #define SECRET_PASS \"enter password\" main Originally a main was created with the following structure. #include <Arduino.h> #include \"arduino_secrets.h\" #include \"thingProperties.h\" setup() { // Initialize serial and wait for port to open: Serial.begin(9600); // This delay gives the chance to wait for a Serial Monitor without blocking if none is found delay(1500); // Defined in thingProperties.h initProperties(); // Connect to Arduino IoT Cloud ArduinoCloud.begin(ArduinoIoTPreferredConnection); /* The following function allows you to obtain more information related to the state of network and IoT Cloud connection and errors the higher number the more granular information you\u2019ll get. The default is 0 (only errors). Maximum is 4 */ setDebugMessageLevel(2); ArduinoCloud.printDebugInfo(); } loop() { ArduinoCloud.update(); } void onMkr1010LedChange() { } Most of the code is self-explanatory. The function ArduinoCloud.update(); is used to reset the Watchdogtimer frequently. The purpose of the Watchdog is to restart the arduino when it does not work corectly. To detect this the watchdog counts down from a certain number and when zero is reached it detects an error and resets the arduino. Therefore the timer must be reset often. The function onMkr1010LedChange() is called from the AIC when a value change of the mkr1010_led variable happend.","title":"Generated Sketch"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#implementation-of-the-measurement-and-the-led","text":"The code to measure temperature and humidity and the sensor is described here . This code is used in the main. An example how to controll an LED can be found here . More changes I have adapted the main of the example so that by inserting the functions example_setup() example_loop() the program is executed. You can add the following code to your main.cpp in the src folder and it should work. #include <arduino.h> #include \"aic_example/example_main.hpp\" void setup() { example_setup(); } void loop() { example_loop(); } Necessary libraries ArduinoIoTCloud.h Arduino_ConnectionHandler.h Adafruit_Sensor.h DHT.h Add the following code to your libraries, if not already present. lib_deps = adafruit/DHT sensor library@^1.4.2 adafruit/Adafruit Unified Sensor@^1.1.4 arduino-libraries/ArduinoIoTCloud@^1.2.1 arduino-libraries/Arduino_ConnectionHandler@^0.6.4","title":"Implementation of the measurement and the LED."},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#how-to-connect-the-sensor-and-the-led","text":"In the example the LED is vonnect at pin 1 and the data output of the DHT11 is connected to pin 0. I used a 220 Ohm resistor for the LED circuit.","title":"How to connect the sensor and the LED"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#dashboard","text":"On the aic website, under dashboards, you will find a large number of widgets that you can simply click together and connect to the variables. I have clicked a few together. This dashboard can be viewed on the website or in the AIC app.","title":"Dashboard"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#more-information","text":"More information (e.g. login to AIC, getting started with AIC) can be found here .","title":"More information"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/","text":"Getting started General preperations Create Agent If you plan to use the Arduino web editor you have to install the Arduino create agent. (Can be found here ). It provides the functionality for the web editor to detect Arduino boards and other supported devices connected to the computer via USB, upload sketches and use the serial monitor. Note: Alternatively, PlatformIO can be used for programming. No create agent is required for PlatformIO. Access the AIC Access AIC from any page on arduino.cc by clicking on the bento menu (9-dots) on the top right corner, or you can go directly to AIC. Login An AIC account has already been created for the project group. The login informations can be found under Dateien\\Administration\\Arduino IoT Cloud\\Zugang.docx in the share point folder. Creating a Thing A new project starts by creating a new Ting. We need to add a device by clicking on the \"Select device\" button on the Thing overview. Here, we choose from any board that we have already been configured, or select the Configure new device option. You can find a list of compatible boards here . Next we can add a variable by clicking on the Add variable button. We can choose name, data type, update the setting and interaction mode for our variable. There are several data types we can choose from, such as int, float, boolean, long, char. There\u2019s also special variables, such as Temperature, Velocity, and Luminance that can be used. Finally, we need to connect to a Wi-Fi network by simply clicking the Configure button in the network section. Enter your network credentials and click Save. This information will also be generated into your sketch file! At the FH we can use the ECEmbedded Wi-Fi network. The Login information can be found in the students room. Building a Sketch A special sketch file can now be found in the Sketch tab, which includes all of the configurations that you have made. When the sketch has been uploaded, it will work as a regular sketch, but it will also update the Cloud variables that we use! Additionally, each time we create a variable that has the Interaction Mode enabled, a function will also be generated. Every time this variable is triggered from the Cloud, it will execute the code within this function! This means that we can leave most of the code out of the loop() and only run code when needed. How to use PlatformIO for the project? The sketch can be editet with the web editor or you can download the sketch and use PlatformIO. PlatformIO provides the function Import Arduino Project wich can be found at the main page of the PlatformIO Gui. In the Web Editor, the included libraries are automatically added to the project during compilation. At PlatformIO we have to add libraries at the .ini file with lib_deps . The libraries specified with lib_deps are automatically downloaded when the code is compiled. The PlatformIO Gui provides under the tab Libraries a function to search and add libraries to a project. Example: lib_deps = adafruit/DHT sensor library@^1.4.2 adafruit/Adafruit Unified Sensor@^1.1.4 arduino-libraries/ArduinoIoTCloud@^1.2.1 arduino-libraries/Arduino_ConnectionHandler@^0.6.4 The advanteg of these library management ist that we can decide wihch version is supposed to be used. This should prevent us from getting into trouble by using different library versions. Creating the dashboard Dashboards are visual user interfaces for interacting with your boards over the Cloud, and we can set up many different setups depending on what your IoT project needs. We can access our dashboards by clicking on the Dashboards tab at the top of the Arduino IoT Cloud interface, where we can create new dashboards, and see a list of dashboards created for other Things. If we click on Create new dashboard, we enter a dashboard editor. Here, we can create something called widgets. Widgets are the visual representation of our variables we create. When we create widgets, we also need to link them to our variables. This is done by clicking on a widget we create, selecting a Thing, and selecting a variable that we want to link. Once it is linked, we can either interact with it, for example a button, or we can monitor a value from a sensor. As long as our board is connected to the cloud, the values will update automatically! The dashboards can be accessed at the AIC website ore with the AIC App. Detailed description of the therminology used Abbreviations Arduinot IoT Cloud = AIC Devices Physical objects built around a board (e.g. MKR WiFi 1010). This is the hardware which runs the sketch, reads sensors, controls actuators and communicates with the Arduino IoT Cloud. Things Logical representation of a connected object. They embody inherent properties of the object, with as little reference to the actual hardware or code used to implement them. Each Thing is represented by a collection of Properties (e.g., temperature, light, pressure...). Properties Qualities defining the characteristics of a system. A Property can be defined as read-only (READ) to indicate that Arduino IoT Cloud can read the data, but cannot change the value of such Property. On the other end, it may be designated to be read-and-write (READWRITE), allowing Arduino IoT Cloud to remotely change the property\u2019s value and trigger an event notification on the device. It is also possible to mark properties as write-only (WRITE) which means the cloud can write to this property but not read its value (this limits data transmission for properties which are used to trigger events only). Source of information This description ist mainly based on the following sources: An intro to the Arduino IoT Cloud from Arduino Docs. Arduino IoT Cloud library Github documentation.","title":"Getting started"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#getting-started","text":"","title":"Getting started"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#general-preperations","text":"Create Agent If you plan to use the Arduino web editor you have to install the Arduino create agent. (Can be found here ). It provides the functionality for the web editor to detect Arduino boards and other supported devices connected to the computer via USB, upload sketches and use the serial monitor. Note: Alternatively, PlatformIO can be used for programming. No create agent is required for PlatformIO. Access the AIC Access AIC from any page on arduino.cc by clicking on the bento menu (9-dots) on the top right corner, or you can go directly to AIC. Login An AIC account has already been created for the project group. The login informations can be found under Dateien\\Administration\\Arduino IoT Cloud\\Zugang.docx in the share point folder.","title":"General preperations"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#creating-a-thing","text":"A new project starts by creating a new Ting. We need to add a device by clicking on the \"Select device\" button on the Thing overview. Here, we choose from any board that we have already been configured, or select the Configure new device option. You can find a list of compatible boards here . Next we can add a variable by clicking on the Add variable button. We can choose name, data type, update the setting and interaction mode for our variable. There are several data types we can choose from, such as int, float, boolean, long, char. There\u2019s also special variables, such as Temperature, Velocity, and Luminance that can be used. Finally, we need to connect to a Wi-Fi network by simply clicking the Configure button in the network section. Enter your network credentials and click Save. This information will also be generated into your sketch file! At the FH we can use the ECEmbedded Wi-Fi network. The Login information can be found in the students room.","title":"Creating a Thing"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#building-a-sketch","text":"A special sketch file can now be found in the Sketch tab, which includes all of the configurations that you have made. When the sketch has been uploaded, it will work as a regular sketch, but it will also update the Cloud variables that we use! Additionally, each time we create a variable that has the Interaction Mode enabled, a function will also be generated. Every time this variable is triggered from the Cloud, it will execute the code within this function! This means that we can leave most of the code out of the loop() and only run code when needed.","title":"Building a Sketch"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#how-to-use-platformio-for-the-project","text":"The sketch can be editet with the web editor or you can download the sketch and use PlatformIO. PlatformIO provides the function Import Arduino Project wich can be found at the main page of the PlatformIO Gui. In the Web Editor, the included libraries are automatically added to the project during compilation. At PlatformIO we have to add libraries at the .ini file with lib_deps . The libraries specified with lib_deps are automatically downloaded when the code is compiled. The PlatformIO Gui provides under the tab Libraries a function to search and add libraries to a project. Example: lib_deps = adafruit/DHT sensor library@^1.4.2 adafruit/Adafruit Unified Sensor@^1.1.4 arduino-libraries/ArduinoIoTCloud@^1.2.1 arduino-libraries/Arduino_ConnectionHandler@^0.6.4 The advanteg of these library management ist that we can decide wihch version is supposed to be used. This should prevent us from getting into trouble by using different library versions.","title":"How to use PlatformIO for the project?"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#creating-the-dashboard","text":"Dashboards are visual user interfaces for interacting with your boards over the Cloud, and we can set up many different setups depending on what your IoT project needs. We can access our dashboards by clicking on the Dashboards tab at the top of the Arduino IoT Cloud interface, where we can create new dashboards, and see a list of dashboards created for other Things. If we click on Create new dashboard, we enter a dashboard editor. Here, we can create something called widgets. Widgets are the visual representation of our variables we create. When we create widgets, we also need to link them to our variables. This is done by clicking on a widget we create, selecting a Thing, and selecting a variable that we want to link. Once it is linked, we can either interact with it, for example a button, or we can monitor a value from a sensor. As long as our board is connected to the cloud, the values will update automatically! The dashboards can be accessed at the AIC website ore with the AIC App.","title":"Creating the dashboard"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#detailed-description-of-the-therminology-used","text":"Abbreviations Arduinot IoT Cloud = AIC Devices Physical objects built around a board (e.g. MKR WiFi 1010). This is the hardware which runs the sketch, reads sensors, controls actuators and communicates with the Arduino IoT Cloud. Things Logical representation of a connected object. They embody inherent properties of the object, with as little reference to the actual hardware or code used to implement them. Each Thing is represented by a collection of Properties (e.g., temperature, light, pressure...). Properties Qualities defining the characteristics of a system. A Property can be defined as read-only (READ) to indicate that Arduino IoT Cloud can read the data, but cannot change the value of such Property. On the other end, it may be designated to be read-and-write (READWRITE), allowing Arduino IoT Cloud to remotely change the property\u2019s value and trigger an event notification on the device. It is also possible to mark properties as write-only (WRITE) which means the cloud can write to this property but not read its value (this limits data transmission for properties which are used to trigger events only).","title":"Detailed description of the therminology used"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#source-of-information","text":"This description ist mainly based on the following sources: An intro to the Arduino IoT Cloud from Arduino Docs. Arduino IoT Cloud library Github documentation.","title":"Source of information"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/","text":"Arduino IoT Cloud overview Concept In the beginning a thing is created. A device is assigned to it. For a thing, several variables can be created, which can have different functionalities and are automatically synchronized with the device. Furthermore, network information must be specified. From this information, a code is automatically generated, which does all the work for the user. The user now only has to insert his own code (e.g. read temperature sensor) and all the work around has already been done automatically. The AIC and the whole process seems to me that it is actually what should come out of our project. Web editor It is possible to edit, compile and load code on devices with this editor. Pros: - Included libraries are automatically found during compiling. - Code is automatically saved in the cloud. Cons: - The code is compiled on Arduino servers, which takes more time than compiling with PLatformIO on my PC. - Git can not be used In my opinion not interesting for our applications. Dashboard The AIC provides a set of widgets to display and control the variables of a thing. The dashboard can be accessed through the AIC website and the AIC App. Libraries The following two libraries are central to using a device with the AIC. ArduinoIoTCloud The ArduinoIoTCloud library is the central element of the firmware enabling certain Arduino boards to connect to the Arduino IoT Cloud. Arduino_ConnectionHandler Library for handling and managing network connections by providing keep-alive functionality and automatic reconnection in case of connection-loss. Further descriptions will follow soon. API Provides a set of endpoints to manage Arduino IoT Cloud Devices, Things, Properties and Timeseries. This API can be called just with any HTTP Client, or using one of these clients: Javascript NPM package Python PYPI Package Golang Module Not tested anything yet. Security All IoT device communications to the cloud use the industry standard SSL protocol for encryption. Arduino MKR and Arduino Portenta board families have on-board crypto-authentication chips and are further secured using X.509 certificate-based authentication. further research necessary. What exactly is the crypto authentication chip used for? Open questions How exactly is the communication AIC - Device and Decive - Device implementet? Somehow with mqtt. How god does the API work? What exactly is the crypto authentication chip used for? Source of information This description ist mainly based on the following sources:","title":"Overview"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#arduino-iot-cloud-overview","text":"","title":"Arduino IoT Cloud overview"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#concept","text":"In the beginning a thing is created. A device is assigned to it. For a thing, several variables can be created, which can have different functionalities and are automatically synchronized with the device. Furthermore, network information must be specified. From this information, a code is automatically generated, which does all the work for the user. The user now only has to insert his own code (e.g. read temperature sensor) and all the work around has already been done automatically. The AIC and the whole process seems to me that it is actually what should come out of our project.","title":"Concept"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#web-editor","text":"It is possible to edit, compile and load code on devices with this editor. Pros: - Included libraries are automatically found during compiling. - Code is automatically saved in the cloud. Cons: - The code is compiled on Arduino servers, which takes more time than compiling with PLatformIO on my PC. - Git can not be used In my opinion not interesting for our applications.","title":"Web editor"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#dashboard","text":"The AIC provides a set of widgets to display and control the variables of a thing. The dashboard can be accessed through the AIC website and the AIC App.","title":"Dashboard"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#libraries","text":"The following two libraries are central to using a device with the AIC. ArduinoIoTCloud The ArduinoIoTCloud library is the central element of the firmware enabling certain Arduino boards to connect to the Arduino IoT Cloud. Arduino_ConnectionHandler Library for handling and managing network connections by providing keep-alive functionality and automatic reconnection in case of connection-loss. Further descriptions will follow soon.","title":"Libraries"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#api","text":"Provides a set of endpoints to manage Arduino IoT Cloud Devices, Things, Properties and Timeseries. This API can be called just with any HTTP Client, or using one of these clients: Javascript NPM package Python PYPI Package Golang Module Not tested anything yet.","title":"API"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#security","text":"All IoT device communications to the cloud use the industry standard SSL protocol for encryption. Arduino MKR and Arduino Portenta board families have on-board crypto-authentication chips and are further secured using X.509 certificate-based authentication. further research necessary. What exactly is the crypto authentication chip used for?","title":"Security"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#open-questions","text":"How exactly is the communication AIC - Device and Decive - Device implementet? Somehow with mqtt. How god does the API work? What exactly is the crypto authentication chip used for?","title":"Open questions"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#source-of-information","text":"This description ist mainly based on the following sources:","title":"Source of information"},{"location":"src/aws/aws-cli/","text":"Command Line Interface The AWS CLI is an open source tool that enables the user to interact with AWS services using commands in the command-line shell. With the CLI basic functionality can be implemented and maintained. Link to the docs The CLI can be used in the Linux shell , in the Windows command line and Remotely . There are different AWS CLI versions. The one used for ECE IoT Prototyping is Version 2.x . Installation The installations is described excellently in the AWS DOCS Linux installation macOS installation Windows installation Tip Have a look here in order to understand what a CLI is!","title":"CLI"},{"location":"src/aws/aws-cli/#command-line-interface","text":"The AWS CLI is an open source tool that enables the user to interact with AWS services using commands in the command-line shell. With the CLI basic functionality can be implemented and maintained. Link to the docs The CLI can be used in the Linux shell , in the Windows command line and Remotely . There are different AWS CLI versions. The one used for ECE IoT Prototyping is Version 2.x .","title":"Command Line Interface"},{"location":"src/aws/aws-cli/#installation","text":"The installations is described excellently in the AWS DOCS Linux installation macOS installation Windows installation Tip Have a look here in order to understand what a CLI is!","title":"Installation"},{"location":"src/aws/aws-iam/","text":"Identity and Access Management IAM is a web service that helps to securely control access to AWS resources. In order to operate securely when handling with multiple developers, projects a good access hierarchy is compulsory. Link to the docs Users Root When creating a AWS account the first user is the root user, which owns the account, has all access rights. This account provides the billing information, has the ability to change the password of all other sub-users . This level of access can be dangerous when handling with lower-level tasks, so it's recommended to not use the root user credentials for everyday development/access. Administrator The Administrator user has almost the same access rights as the root. The biggest exception is that the Administrator is not the owner of the account. An Administrator can be used for managing the rest of the Accounts with a extra level of security. Developer Multiple developer accounts can be created. They do have access to the certain resource in which they are building the desired Application. Groups and Policies Summed up, those two sections are used to an easier management of different resource distribution. Warning This summary is only a rough overview of the complex functionality of AWS IAM. In order to get a deeper understanding reading the docs is mandatory!","title":"Identity and Access Management"},{"location":"src/aws/aws-iam/#identity-and-access-management","text":"IAM is a web service that helps to securely control access to AWS resources. In order to operate securely when handling with multiple developers, projects a good access hierarchy is compulsory. Link to the docs","title":"Identity and Access Management"},{"location":"src/aws/aws-iam/#users","text":"","title":"Users"},{"location":"src/aws/aws-iam/#root","text":"When creating a AWS account the first user is the root user, which owns the account, has all access rights. This account provides the billing information, has the ability to change the password of all other sub-users . This level of access can be dangerous when handling with lower-level tasks, so it's recommended to not use the root user credentials for everyday development/access.","title":"Root"},{"location":"src/aws/aws-iam/#administrator","text":"The Administrator user has almost the same access rights as the root. The biggest exception is that the Administrator is not the owner of the account. An Administrator can be used for managing the rest of the Accounts with a extra level of security.","title":"Administrator"},{"location":"src/aws/aws-iam/#developer","text":"Multiple developer accounts can be created. They do have access to the certain resource in which they are building the desired Application.","title":"Developer"},{"location":"src/aws/aws-iam/#groups-and-policies","text":"Summed up, those two sections are used to an easier management of different resource distribution. Warning This summary is only a rough overview of the complex functionality of AWS IAM. In order to get a deeper understanding reading the docs is mandatory!","title":"Groups and Policies"},{"location":"src/hardware/CO2/CCS881/","text":"Adafruit CCS811 CO2 sensor CCS811 Ultra small Design Can be used with 3.3V or 5V logic level Can used also with an Raspberry PI with Python Can detect Alcohols, Aldehydes, Ketones, Organic Acids, Amines, Aliphatic and Aromatic Hydrocarbons Body size: 25.4mm x 17.8mm x 2.1mm Got two mounting holes with a diameter of 2.5mm for M2.5 screws Communication Interface: I2C It measures eCO2 within a range of 400 to 8192 ppm and TVOC withing a range of 0 to 1187 ppb Includes an voltage regulator which provides 3.3V and 100mA 3 power pins: Vin, GND and 3Vo(3.3V output), 3 logic pins: SCL, SDA and STEMMA QT 3 other pins: INT, WAKE and RST Can be connected with a STEMMA QT Connector More information can be found here Picture of the sensor Libraries \"Adafruit_seesaw.h\" Implementation Example Code #include \"Adafruit_CCS811.h\" Adafruit_CCS811 ccs; void setup() { Serial.begin(9600); Serial.println(\"CCS811 test\"); if(!ccs.begin()){ Serial.println(\"Failed to start sensor! Please check your wiring.\"); while(1); } // Wait for the sensor to be ready while(!ccs.available()); } void loop() { if(ccs.available()){ if(!ccs.readData()){ Serial.print(\"CO2: \"); Serial.print(ccs.geteCO2()); Serial.print(\"ppm, TVOC: \"); Serial.println(ccs.getTVOC()); } else{ Serial.println(\"ERROR!\"); while(1); } } delay(500); } How to connect the sensor on the Arduino","title":"CCS881"},{"location":"src/hardware/CO2/CCS881/#adafruit-ccs811-co2-sensor","text":"","title":"Adafruit CCS811 CO2 sensor"},{"location":"src/hardware/CO2/CCS881/#ccs811","text":"Ultra small Design Can be used with 3.3V or 5V logic level Can used also with an Raspberry PI with Python Can detect Alcohols, Aldehydes, Ketones, Organic Acids, Amines, Aliphatic and Aromatic Hydrocarbons Body size: 25.4mm x 17.8mm x 2.1mm Got two mounting holes with a diameter of 2.5mm for M2.5 screws Communication Interface: I2C It measures eCO2 within a range of 400 to 8192 ppm and TVOC withing a range of 0 to 1187 ppb Includes an voltage regulator which provides 3.3V and 100mA 3 power pins: Vin, GND and 3Vo(3.3V output), 3 logic pins: SCL, SDA and STEMMA QT 3 other pins: INT, WAKE and RST Can be connected with a STEMMA QT Connector More information can be found here","title":"CCS811"},{"location":"src/hardware/CO2/CCS881/#picture-of-the-sensor","text":"","title":"Picture of the sensor"},{"location":"src/hardware/CO2/CCS881/#libraries","text":"\"Adafruit_seesaw.h\"","title":"Libraries"},{"location":"src/hardware/CO2/CCS881/#implementation","text":"","title":"Implementation"},{"location":"src/hardware/CO2/CCS881/#example-code","text":"#include \"Adafruit_CCS811.h\" Adafruit_CCS811 ccs; void setup() { Serial.begin(9600); Serial.println(\"CCS811 test\"); if(!ccs.begin()){ Serial.println(\"Failed to start sensor! Please check your wiring.\"); while(1); } // Wait for the sensor to be ready while(!ccs.available()); } void loop() { if(ccs.available()){ if(!ccs.readData()){ Serial.print(\"CO2: \"); Serial.print(ccs.geteCO2()); Serial.print(\"ppm, TVOC: \"); Serial.println(ccs.getTVOC()); } else{ Serial.println(\"ERROR!\"); while(1); } } delay(500); }","title":"Example Code"},{"location":"src/hardware/CO2/CCS881/#how-to-connect-the-sensor-on-the-arduino","text":"","title":"How to connect the sensor on the Arduino"},{"location":"src/hardware/Rainfall-quantity/xxx/","text":"Temperature and humidity Sensor DHT11 DHT11 Libraries Implementation","title":"Xxx"},{"location":"src/hardware/Rainfall-quantity/xxx/#temperature-and-humidity-sensor-dht11","text":"","title":"Temperature and humidity Sensor DHT11"},{"location":"src/hardware/Rainfall-quantity/xxx/#dht11","text":"","title":"DHT11"},{"location":"src/hardware/Rainfall-quantity/xxx/#libraries","text":"","title":"Libraries"},{"location":"src/hardware/Rainfall-quantity/xxx/#implementation","text":"","title":"Implementation"},{"location":"src/hardware/air-pressure/LPS25HB/","text":"Air-Pressure Sensor - LPS25HB LPS25HB 3,3 to 5V power and I/O Range: 260-1260 hPa Accuracy: 0.2 hPa after calibration +-1 hPa before calibration maximum Sampling Rate: 25Hz Body size: 25mm X 25mm X 7,6mm Form Faktor: STEMMA QT / Qwiic Current Consumption: High resolution mode: 25\u00b5A low power mode: 4\u00b5A Communication Interface: I2C, SPI More information can be found here or [here] (https://learn.adafruit.com/adafruit-lps25-pressure-sensor) Libraries Adafruit LPS2X Library Adafruit BusIO Library Adafruit Unified Sensor Library Implementation // Basic demo for pressure readings from Adafruit LPS2X include include include // For SPI mode, we need a CS pin define LPS_CS 10 // For software-SPI mode we need SCK/MOSI/MISO pins define LPS_SCK 13 define LPS_MISO 12 define LPS_MOSI 11 Adafruit_LPS25 lps; void setup(void) { Serial.begin(115200); while (!Serial) delay(10); // will pause Zero, Leonardo, etc until serial console opens Serial.println(\"Adafruit LPS25 test!\"); // Try to initialize! if (!lps.begin_I2C()) { //if (!lps.begin_SPI(LPS_CS)) { //if (!lps.begin_SPI(LPS_CS, LPS_SCK, LPS_MISO, LPS_MOSI)) { Serial.println(\"Failed to find LPS25 chip\"); while (1) { delay(10); } } Serial.println(\"LPS25 Found!\"); // lps.setDataRate(LPS25_RATE_12_5_HZ); Serial.print(\"Data rate set to: \"); switch (lps.getDataRate()) { case LPS25_RATE_ONE_SHOT: Serial.println(\"One Shot\"); break; case LPS25_RATE_1_HZ: Serial.println(\"1 Hz\"); break; case LPS25_RATE_7_HZ: Serial.println(\"7 Hz\"); break; case LPS25_RATE_12_5_HZ: Serial.println(\"12.5 Hz\"); break; case LPS25_RATE_25_HZ: Serial.println(\"25 Hz\"); break; } } void loop() { sensors_event_t temp; sensors_event_t pressure; lps.getEvent(&pressure, &temp);// get pressure Serial.print(\"Temperature: \");Serial.print(temp.temperature);Serial.println(\" degrees C\"); Serial.print(\"Pressure: \");Serial.print(pressure.pressure);Serial.println(\" hPa\"); Serial.println(\"\"); delay(100); }","title":"Air-Pressure Sensor - LPS25HB"},{"location":"src/hardware/air-pressure/LPS25HB/#air-pressure-sensor-lps25hb","text":"","title":"Air-Pressure Sensor - LPS25HB"},{"location":"src/hardware/air-pressure/LPS25HB/#lps25hb","text":"3,3 to 5V power and I/O Range: 260-1260 hPa Accuracy: 0.2 hPa after calibration +-1 hPa before calibration maximum Sampling Rate: 25Hz Body size: 25mm X 25mm X 7,6mm Form Faktor: STEMMA QT / Qwiic Current Consumption: High resolution mode: 25\u00b5A low power mode: 4\u00b5A Communication Interface: I2C, SPI More information can be found here or [here] (https://learn.adafruit.com/adafruit-lps25-pressure-sensor)","title":"LPS25HB"},{"location":"src/hardware/air-pressure/LPS25HB/#libraries","text":"Adafruit LPS2X Library Adafruit BusIO Library Adafruit Unified Sensor Library","title":"Libraries"},{"location":"src/hardware/air-pressure/LPS25HB/#implementation","text":"// Basic demo for pressure readings from Adafruit LPS2X","title":"Implementation"},{"location":"src/hardware/air-pressure/LPS25HB/#include","text":"","title":"include "},{"location":"src/hardware/air-pressure/LPS25HB/#include_1","text":"","title":"include "},{"location":"src/hardware/air-pressure/LPS25HB/#include_2","text":"// For SPI mode, we need a CS pin","title":"include "},{"location":"src/hardware/air-pressure/LPS25HB/#define-lps_cs-10","text":"// For software-SPI mode we need SCK/MOSI/MISO pins","title":"define LPS_CS 10"},{"location":"src/hardware/air-pressure/LPS25HB/#define-lps_sck-13","text":"","title":"define LPS_SCK 13"},{"location":"src/hardware/air-pressure/LPS25HB/#define-lps_miso-12","text":"","title":"define LPS_MISO 12"},{"location":"src/hardware/air-pressure/LPS25HB/#define-lps_mosi-11","text":"Adafruit_LPS25 lps; void setup(void) { Serial.begin(115200); while (!Serial) delay(10); // will pause Zero, Leonardo, etc until serial console opens Serial.println(\"Adafruit LPS25 test!\"); // Try to initialize! if (!lps.begin_I2C()) { //if (!lps.begin_SPI(LPS_CS)) { //if (!lps.begin_SPI(LPS_CS, LPS_SCK, LPS_MISO, LPS_MOSI)) { Serial.println(\"Failed to find LPS25 chip\"); while (1) { delay(10); } } Serial.println(\"LPS25 Found!\"); // lps.setDataRate(LPS25_RATE_12_5_HZ); Serial.print(\"Data rate set to: \"); switch (lps.getDataRate()) { case LPS25_RATE_ONE_SHOT: Serial.println(\"One Shot\"); break; case LPS25_RATE_1_HZ: Serial.println(\"1 Hz\"); break; case LPS25_RATE_7_HZ: Serial.println(\"7 Hz\"); break; case LPS25_RATE_12_5_HZ: Serial.println(\"12.5 Hz\"); break; case LPS25_RATE_25_HZ: Serial.println(\"25 Hz\"); break; } } void loop() { sensors_event_t temp; sensors_event_t pressure; lps.getEvent(&pressure, &temp);// get pressure Serial.print(\"Temperature: \");Serial.print(temp.temperature);Serial.println(\" degrees C\"); Serial.print(\"Pressure: \");Serial.print(pressure.pressure);Serial.println(\" hPa\"); Serial.println(\"\"); delay(100); }","title":"define LPS_MOSI 11"},{"location":"src/hardware/air-quality%28VOC%29/PMSA003I/","text":"Air Quality Sensor PMSA003I Air Quality Breakout PMSA003I (PM 0.1\u00b5-2.5\u00b5-10.0\u00b5) 3,3 to 5V power and I/O Range: PM1.0, PM2.5 and PM10.0 concentration in both standard & environmental units Particulate matter per 0.1L air, categorized into 0.3um, 0.5um, 1.0um, 2.5um, 5.0um and 10um size bins maximum Sampling Rate: 1Hz Form Faktor: STEMMA QT Communication Interface: I2C More information can be found here Libraries Adafruit PM25 AQI libary Adafruit BusIO libary Implementation / Test sketch for Adafruit PM2.5 sensor with UART or I2C / include \"Adafruit_PM25AQI.h\" // If your PM2.5 is UART only, for UNO and others (without hardware serial) // we must use software serial... // pin #2 is IN from sensor (TX pin on sensor), leave pin #3 disconnected // comment these two lines if using hardware serial //#include //SoftwareSerial pmSerial(2, 3); Adafruit_PM25AQI aqi = Adafruit_PM25AQI(); void setup() { // Wait for serial monitor to open Serial.begin(115200); while (!Serial) delay(10); Serial.println(\"Adafruit PMSA003I Air Quality Sensor\"); // Wait one second for sensor to boot up! delay(1000); // If using serial, initialize it and set baudrate before starting! // Uncomment one of the following //Serial1.begin(9600); //pmSerial.begin(9600); // There are 3 options for connectivity! if (! aqi.begin_I2C()) { // connect to the sensor over I2C //if (! aqi.begin_UART(&Serial1)) { // connect to the sensor over hardware serial //if (! aqi.begin_UART(&pmSerial)) { // connect to the sensor over software serial Serial.println(\"Could not find PM 2.5 sensor!\"); while (1) delay(10); } Serial.println(\"PM25 found!\"); } void loop() { PM25_AQI_Data data; if (! aqi.read(&data)) { Serial.println(\"Could not read from AQI\"); delay(500); // try again in a bit! return; } Serial.println(\"AQI reading success\"); Serial.println(); Serial.println(F(\"---------------------------------------\")); Serial.println(F(\"Concentration Units (standard)\")); Serial.println(F(\"---------------------------------------\")); Serial.print(F(\"PM 1.0: \")); Serial.print(data.pm10_standard); Serial.print(F(\"\\t\\tPM 2.5: \")); Serial.print(data.pm25_standard); Serial.print(F(\"\\t\\tPM 10: \")); Serial.println(data.pm100_standard); Serial.println(F(\"Concentration Units (environmental)\")); Serial.println(F(\"---------------------------------------\")); Serial.print(F(\"PM 1.0: \")); Serial.print(data.pm10_env); Serial.print(F(\"\\t\\tPM 2.5: \")); Serial.print(data.pm25_env); Serial.print(F(\"\\t\\tPM 10: \")); Serial.println(data.pm100_env); Serial.println(F(\"---------------------------------------\")); Serial.print(F(\"Particles > 0.3um / 0.1L air:\")); Serial.println(data.particles_03um); Serial.print(F(\"Particles > 0.5um / 0.1L air:\")); Serial.println(data.particles_05um); Serial.print(F(\"Particles > 1.0um / 0.1L air:\")); Serial.println(data.particles_10um); Serial.print(F(\"Particles > 2.5um / 0.1L air:\")); Serial.println(data.particles_25um); Serial.print(F(\"Particles > 5.0um / 0.1L air:\")); Serial.println(data.particles_50um); Serial.print(F(\"Particles > 10 um / 0.1L air:\")); Serial.println(data.particles_100um); Serial.println(F(\"---------------------------------------\")); delay(1000); }","title":"Air Quality Sensor PMSA003I Air Quality Breakout"},{"location":"src/hardware/air-quality%28VOC%29/PMSA003I/#air-quality-sensor-pmsa003i-air-quality-breakout","text":"","title":"Air Quality Sensor PMSA003I Air Quality Breakout"},{"location":"src/hardware/air-quality%28VOC%29/PMSA003I/#pmsa003i-pm-01-25-100","text":"3,3 to 5V power and I/O Range: PM1.0, PM2.5 and PM10.0 concentration in both standard & environmental units Particulate matter per 0.1L air, categorized into 0.3um, 0.5um, 1.0um, 2.5um, 5.0um and 10um size bins maximum Sampling Rate: 1Hz Form Faktor: STEMMA QT Communication Interface: I2C More information can be found here","title":"PMSA003I (PM 0.1\u00b5-2.5\u00b5-10.0\u00b5)"},{"location":"src/hardware/air-quality%28VOC%29/PMSA003I/#libraries","text":"Adafruit PM25 AQI libary Adafruit BusIO libary","title":"Libraries"},{"location":"src/hardware/air-quality%28VOC%29/PMSA003I/#implementation","text":"/ Test sketch for Adafruit PM2.5 sensor with UART or I2C /","title":"Implementation"},{"location":"src/hardware/air-quality%28VOC%29/PMSA003I/#include-adafruit_pm25aqih","text":"// If your PM2.5 is UART only, for UNO and others (without hardware serial) // we must use software serial... // pin #2 is IN from sensor (TX pin on sensor), leave pin #3 disconnected // comment these two lines if using hardware serial //#include //SoftwareSerial pmSerial(2, 3); Adafruit_PM25AQI aqi = Adafruit_PM25AQI(); void setup() { // Wait for serial monitor to open Serial.begin(115200); while (!Serial) delay(10); Serial.println(\"Adafruit PMSA003I Air Quality Sensor\"); // Wait one second for sensor to boot up! delay(1000); // If using serial, initialize it and set baudrate before starting! // Uncomment one of the following //Serial1.begin(9600); //pmSerial.begin(9600); // There are 3 options for connectivity! if (! aqi.begin_I2C()) { // connect to the sensor over I2C //if (! aqi.begin_UART(&Serial1)) { // connect to the sensor over hardware serial //if (! aqi.begin_UART(&pmSerial)) { // connect to the sensor over software serial Serial.println(\"Could not find PM 2.5 sensor!\"); while (1) delay(10); } Serial.println(\"PM25 found!\"); } void loop() { PM25_AQI_Data data; if (! aqi.read(&data)) { Serial.println(\"Could not read from AQI\"); delay(500); // try again in a bit! return; } Serial.println(\"AQI reading success\"); Serial.println(); Serial.println(F(\"---------------------------------------\")); Serial.println(F(\"Concentration Units (standard)\")); Serial.println(F(\"---------------------------------------\")); Serial.print(F(\"PM 1.0: \")); Serial.print(data.pm10_standard); Serial.print(F(\"\\t\\tPM 2.5: \")); Serial.print(data.pm25_standard); Serial.print(F(\"\\t\\tPM 10: \")); Serial.println(data.pm100_standard); Serial.println(F(\"Concentration Units (environmental)\")); Serial.println(F(\"---------------------------------------\")); Serial.print(F(\"PM 1.0: \")); Serial.print(data.pm10_env); Serial.print(F(\"\\t\\tPM 2.5: \")); Serial.print(data.pm25_env); Serial.print(F(\"\\t\\tPM 10: \")); Serial.println(data.pm100_env); Serial.println(F(\"---------------------------------------\")); Serial.print(F(\"Particles > 0.3um / 0.1L air:\")); Serial.println(data.particles_03um); Serial.print(F(\"Particles > 0.5um / 0.1L air:\")); Serial.println(data.particles_05um); Serial.print(F(\"Particles > 1.0um / 0.1L air:\")); Serial.println(data.particles_10um); Serial.print(F(\"Particles > 2.5um / 0.1L air:\")); Serial.println(data.particles_25um); Serial.print(F(\"Particles > 5.0um / 0.1L air:\")); Serial.println(data.particles_50um); Serial.print(F(\"Particles > 10 um / 0.1L air:\")); Serial.println(data.particles_100um); Serial.println(F(\"---------------------------------------\")); delay(1000); }","title":"include \"Adafruit_PM25AQI.h\""},{"location":"src/hardware/brightness/VEML7700/","text":"Ambient Light Sensor Adafruit VEML7700 VEML7700 Ultra small Design Can be used with 3.3V or 5V logic level Cas used also with an Raspberry PI with Python Ambient light detection from 0 to 120 LUX with resoltion down to 0.0036 lx/ct No more than 1 Hz sampling rate (once every second) Body size: 16.5mm x 16.5mm x 2.1mm Got two mounting holes with a diameter of 2.5mm for M2.5 screws Communication Interface: I2C Includes an voltage regulator which provides 3.3V and 100mA 5 pins: Vin, GND, 3Vo(3.3V output), SCL, SDA More information can be found here Picture from the PCB License for PCB Design This PCB is Attribution-ShareAlike 3.0 Unported. This means it`s possible to copy and redistribute the material in any medium or format. Also it can be remix, transform, and build upon the material for any purpose, even commercially. But, you must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. More informations for Attribution-ShareAlike 3.0 Unported see here PCB files are here Library Adafruit_VEML7700.h Implementation Example Code #include \"Adafruit_VEML7700.h\" Adafruit_VEML7700 veml = Adafruit_VEML7700(); void setup() { while (!Serial) { delay(10); } Serial.begin(115200); Serial.println(\"Adafruit VEML7700 Test\"); if (!veml.begin()) { Serial.println(\"Sensor not found\"); while (1); } Serial.println(\"Sensor found\"); veml.setGain(VEML7700_GAIN_1); veml.setIntegrationTime(VEML7700_IT_800MS); Serial.print(F(\"Gain: \")); switch (veml.getGain()) { case VEML7700_GAIN_1: Serial.println(\"1\"); break; case VEML7700_GAIN_2: Serial.println(\"2\"); break; case VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break; case VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break; } Serial.print(F(\"Integration Time (ms): \")); switch (veml.getIntegrationTime()) { case VEML7700_IT_25MS: Serial.println(\"25\"); break; case VEML7700_IT_50MS: Serial.println(\"50\"); break; case VEML7700_IT_100MS: Serial.println(\"100\"); break; case VEML7700_IT_200MS: Serial.println(\"200\"); break; case VEML7700_IT_400MS: Serial.println(\"400\"); break; case VEML7700_IT_800MS: Serial.println(\"800\"); break; } //veml.powerSaveEnable(true); //veml.setPowerSaveMode(VEML7700_POWERSAVE_MODE4); veml.setLowThreshold(10000); veml.setHighThreshold(20000); veml.interruptEnable(true); } void loop() { Serial.print(\"Lux: \"); Serial.println(veml.readLux()); Serial.print(\"White: \"); Serial.println(veml.readWhite()); Serial.print(\"Raw ALS: \"); Serial.println(veml.readALS()); uint16_t irq = veml.interruptStatus(); if (irq & VEML7700_INTERRUPT_LOW) { Serial.println(\"** Low threshold\"); } if (irq & VEML7700_INTERRUPT_HIGH) { Serial.println(\"** High threshold\"); } delay(500); }","title":"VEML7700"},{"location":"src/hardware/brightness/VEML7700/#ambient-light-sensor-adafruit-veml7700","text":"","title":"Ambient Light Sensor Adafruit VEML7700"},{"location":"src/hardware/brightness/VEML7700/#veml7700","text":"Ultra small Design Can be used with 3.3V or 5V logic level Cas used also with an Raspberry PI with Python Ambient light detection from 0 to 120 LUX with resoltion down to 0.0036 lx/ct No more than 1 Hz sampling rate (once every second) Body size: 16.5mm x 16.5mm x 2.1mm Got two mounting holes with a diameter of 2.5mm for M2.5 screws Communication Interface: I2C Includes an voltage regulator which provides 3.3V and 100mA 5 pins: Vin, GND, 3Vo(3.3V output), SCL, SDA More information can be found here","title":"VEML7700"},{"location":"src/hardware/brightness/VEML7700/#picture-from-the-pcb","text":"","title":"Picture from the PCB"},{"location":"src/hardware/brightness/VEML7700/#license-for-pcb-design","text":"This PCB is Attribution-ShareAlike 3.0 Unported. This means it`s possible to copy and redistribute the material in any medium or format. Also it can be remix, transform, and build upon the material for any purpose, even commercially. But, you must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use. If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original. More informations for Attribution-ShareAlike 3.0 Unported see here PCB files are here","title":"License for PCB Design"},{"location":"src/hardware/brightness/VEML7700/#library","text":"Adafruit_VEML7700.h","title":"Library"},{"location":"src/hardware/brightness/VEML7700/#implementation","text":"","title":"Implementation"},{"location":"src/hardware/brightness/VEML7700/#example-code","text":"#include \"Adafruit_VEML7700.h\" Adafruit_VEML7700 veml = Adafruit_VEML7700(); void setup() { while (!Serial) { delay(10); } Serial.begin(115200); Serial.println(\"Adafruit VEML7700 Test\"); if (!veml.begin()) { Serial.println(\"Sensor not found\"); while (1); } Serial.println(\"Sensor found\"); veml.setGain(VEML7700_GAIN_1); veml.setIntegrationTime(VEML7700_IT_800MS); Serial.print(F(\"Gain: \")); switch (veml.getGain()) { case VEML7700_GAIN_1: Serial.println(\"1\"); break; case VEML7700_GAIN_2: Serial.println(\"2\"); break; case VEML7700_GAIN_1_4: Serial.println(\"1/4\"); break; case VEML7700_GAIN_1_8: Serial.println(\"1/8\"); break; } Serial.print(F(\"Integration Time (ms): \")); switch (veml.getIntegrationTime()) { case VEML7700_IT_25MS: Serial.println(\"25\"); break; case VEML7700_IT_50MS: Serial.println(\"50\"); break; case VEML7700_IT_100MS: Serial.println(\"100\"); break; case VEML7700_IT_200MS: Serial.println(\"200\"); break; case VEML7700_IT_400MS: Serial.println(\"400\"); break; case VEML7700_IT_800MS: Serial.println(\"800\"); break; } //veml.powerSaveEnable(true); //veml.setPowerSaveMode(VEML7700_POWERSAVE_MODE4); veml.setLowThreshold(10000); veml.setHighThreshold(20000); veml.interruptEnable(true); } void loop() { Serial.print(\"Lux: \"); Serial.println(veml.readLux()); Serial.print(\"White: \"); Serial.println(veml.readWhite()); Serial.print(\"Raw ALS: \"); Serial.println(veml.readALS()); uint16_t irq = veml.interruptStatus(); if (irq & VEML7700_INTERRUPT_LOW) { Serial.println(\"** Low threshold\"); } if (irq & VEML7700_INTERRUPT_HIGH) { Serial.println(\"** High threshold\"); } delay(500); }","title":"Example Code"},{"location":"src/hardware/oxygen/xxx/","text":"Temperature and humidity Sensor DHT11 DHT11 Libraries Implementation","title":"Xxx"},{"location":"src/hardware/oxygen/xxx/#temperature-and-humidity-sensor-dht11","text":"","title":"Temperature and humidity Sensor DHT11"},{"location":"src/hardware/oxygen/xxx/#dht11","text":"","title":"DHT11"},{"location":"src/hardware/oxygen/xxx/#libraries","text":"","title":"Libraries"},{"location":"src/hardware/oxygen/xxx/#implementation","text":"","title":"Implementation"},{"location":"src/hardware/ph-value/EZO-pH/","text":"PH- Sensor Atlas Scientific EZO-pH Atlas Scientific EZO-pH 3.3 to 5V power and I/O Range: 0.001-14 Accuracy: \u00b1 0,002 Body size : 13.97mm x 20.16mm Communication Interface: I2C, UART More information can be found here or [here] (https://learn.adafruit.com/reef-pi-guide-7-ph-monitoring/overview) or [here] (https://www.exp-tech.de/module/chemie/6134/ezo-ph-circuit) requieres a probe for testing! Libraries Ezo I2C libary Ezo UART libary Implementation arduino //This code was written to be easy to understand. //Modify this code as you see fit. //This code will output data to the Arduino serial monitor. //Type commands into the Arduino serial monitor to control the pH circuit. //This code was written in the Arduino 1.8.9 IDE //An Arduino UNO was used to test this code. //This code was last tested 6/2019 include //we have to include the SoftwareSerial library, or else we can't use it define rx 2 //define what pin rx is going to be define tx 3 //define what pin tx is going to be SoftwareSerial myserial(rx, tx); //define how the soft serial port is going to work String inputstring = \"\"; //a string to hold incoming data from the PC String sensorstring = \"\"; //a string to hold the data from the Atlas Scientific product boolean input_string_complete = false; //have we received all the data from the PC boolean sensor_string_complete = false; //have we received all the data from the Atlas Scientific product float pH; //used to hold a floating point number that is the pH void setup() { //set up the hardware Serial.begin(9600); //set baud rate for the hardware serial port_0 to 9600 myserial.begin(9600); //set baud rate for the software serial port to 9600 inputstring.reserve(10); //set aside some bytes for receiving data from the PC sensorstring.reserve(30); //set aside some bytes for receiving data from Atlas Scientific product } void serialEvent() { //if the hardware serial port_0 receives a char inputstring = Serial.readStringUntil(13); //read the string until we see a input_string_complete = true; //set the flag used to tell if we have received a completed string from the PC } void loop() { //here we go... if (input_string_complete == true) { //if a string from the PC has been received in its entirety myserial.print(inputstring); //send that string to the Atlas Scientific product myserial.print('\\r'); //add a to the end of the string inputstring = \"\"; //clear the string input_string_complete = false; //reset the flag used to tell if we have received a completed string from the PC } if (myserial.available() > 0) { //if we see that the Atlas Scientific product has sent a character char inchar = (char)myserial.read(); //get the char we just received sensorstring += inchar; //add the char to the var called sensorstring if (inchar == '\\r') { //if the incoming character is a sensor_string_complete = true; //set the flag } } if (sensor_string_complete == true) { //if a string from the Atlas Scientific product has been received in its entirety Serial.println(sensorstring); //send that string to the PC's serial monitor / //uncomment this section to see how to convert the pH reading from a string to a float if (isdigit(sensorstring[0])) { //if the first character in the string is a digit pH = sensorstring.toFloat(); //convert the string to a floating point number so it can be evaluated by the Arduino if (pH >= 7.0) { //if the pH is greater than or equal to 7.0 Serial.println(\"high\"); //print \"high\" this is demonstrating that the Arduino is evaluating the pH as a number and not as a string } if (pH <= 6.999) { //if the pH is less than or equal to 6.999 Serial.println(\"low\"); //print \"low\" this is demonstrating that the Arduino is evaluating the pH as a number and not as a string } } / sensorstring = \"\"; //clear the string sensor_string_complete = false; //reset the flag used to tell if we have received a completed string from the Atlas Scientific product } } I2C //This code will work on an Arduino Uno and Mega //This code was written to be easy to understand. //Modify this code as you see fit. //This code will output data to the Arduino serial monitor. //Type commands into the Arduino serial monitor to control the Ph circuit. //This code was written in the Arduino 1.8.9 IDE //This code was last tested 7/2019 include //enable I2C. define address 99 //default I2C ID number for EZO pH Circuit. char computerdata[20]; //we make a 20 byte character array to hold incoming data from a pc/mac/other. byte received_from_computer = 0; //we need to know how many characters have been received. byte serial_event = 0; //a flag to signal when data has been received from the pc/mac/other. byte code = 0; //used to hold the I2C response code. char ph_data[20]; //we make a 20 byte character array to hold incoming data from the pH circuit. byte in_char = 0; //used as a 1 byte buffer to store inbound bytes from the pH Circuit. byte i = 0; //counter used for ph_data array. int time_ = 815; //used to change the delay needed depending on the command sent to the EZO Class pH Circuit. float ph_float; //float var used to hold the float value of the pH. void setup() //hardware initialization. { Serial.begin(9600); //enable serial port. Wire.begin(); //enable I2C port. } void serialEvent() { //this interrupt will trigger when the data coming from the serial monitor(pc/mac/other) is received. received_from_computer = Serial.readBytesUntil(13, computerdata, 20); //we read the data sent from the serial monitor(pc/mac/other) until we see a . We also count how many characters have been received. computerdata[received_from_computer] = 0; //stop the buffer from transmitting leftovers or garbage. serial_event = true; //set the serial event flag. } void loop() { //the main loop. if (serial_event == true) { //if a command was sent to the EZO device. for (i = 0; i <= received_from_computer; i++) { //set all char to lower case, this is just so this exact sample code can recognize the \"sleep\" command. computerdata[i] = tolower(computerdata[i]); //\"Sleep\" \u2260 \"sleep\" } i=0; //reset i, we will need it later if (computerdata[0] == 'c' || computerdata[0] == 'r')time_ = 815; //if a command has been sent to calibrate or take a reading we wait 815ms so that the circuit has time to take the reading. else time_ = 250; //if any other command has been sent we wait only 250ms. Wire.beginTransmission(address); //call the circuit by its ID number. Wire.write(computerdata); //transmit the command that was sent through the serial port. Wire.endTransmission(); //end the I2C data transmission. if (strcmp(computerdata, \"sleep\") != 0) { //if the command that has been sent is NOT the sleep command, wait the correct amount of time and request data. //if it is the sleep command, we do nothing. Issuing a sleep command and then requesting data will wake the circuit. delay(time_); //wait the correct amount of time for the circuit to complete its instruction. Wire.requestFrom(address, 20, 1); //call the circuit and request 20 bytes (this may be more than we need) code = Wire.read(); //the first byte is the response code, we read this separately. switch (code) { //switch case based on what the response code is. case 1: //decimal 1. Serial.println(\"Success\"); //means the command was successful. break; //exits the switch case. case 2: //decimal 2. Serial.println(\"Failed\"); //means the command has failed. break; //exits the switch case. case 254: //decimal 254. Serial.println(\"Pending\"); //means the command has not yet been finished calculating. break; //exits the switch case. case 255: //decimal 255. Serial.println(\"No Data\"); //means there is no further data to send. break; //exits the switch case. } while (Wire.available()) { //are there bytes to receive. in_char = Wire.read(); //receive a byte. ph_data[i] = in_char; //load this byte into our array. i += 1; //incur the counter for the array element. if (in_char == 0) { //if we see that we have been sent a null command. i = 0; //reset the counter i to 0. break; //exit the while loop. } } Serial.println(ph_data); //print the data. } serial_event = false; //reset the serial event flag. } //Uncomment this section if you want to take the pH value and convert it into floating point number. //ph_float=atof(ph_data); }","title":"PH- Sensor Atlas Scientific EZO-pH"},{"location":"src/hardware/ph-value/EZO-pH/#ph-sensor-atlas-scientific-ezo-ph","text":"","title":"PH- Sensor Atlas Scientific EZO-pH"},{"location":"src/hardware/ph-value/EZO-pH/#atlas-scientific-ezo-ph","text":"3.3 to 5V power and I/O Range: 0.001-14 Accuracy: \u00b1 0,002 Body size : 13.97mm x 20.16mm Communication Interface: I2C, UART More information can be found here or [here] (https://learn.adafruit.com/reef-pi-guide-7-ph-monitoring/overview) or [here] (https://www.exp-tech.de/module/chemie/6134/ezo-ph-circuit) requieres a probe for testing!","title":"Atlas Scientific EZO-pH"},{"location":"src/hardware/ph-value/EZO-pH/#libraries","text":"Ezo I2C libary Ezo UART libary","title":"Libraries"},{"location":"src/hardware/ph-value/EZO-pH/#implementation","text":"","title":"Implementation"},{"location":"src/hardware/ph-value/EZO-pH/#arduino","text":"//This code was written to be easy to understand. //Modify this code as you see fit. //This code will output data to the Arduino serial monitor. //Type commands into the Arduino serial monitor to control the pH circuit. //This code was written in the Arduino 1.8.9 IDE //An Arduino UNO was used to test this code. //This code was last tested 6/2019","title":"arduino"},{"location":"src/hardware/ph-value/EZO-pH/#include-we-have-to-include-the-softwareserial-library-or-else-we-cant-use-it","text":"","title":"include                            //we have to include the SoftwareSerial library, or else we can't use it"},{"location":"src/hardware/ph-value/EZO-pH/#define-rx-2-define-what-pin-rx-is-going-to-be","text":"","title":"define rx 2                                          //define what pin rx is going to be"},{"location":"src/hardware/ph-value/EZO-pH/#define-tx-3-define-what-pin-tx-is-going-to-be","text":"SoftwareSerial myserial(rx, tx); //define how the soft serial port is going to work String inputstring = \"\"; //a string to hold incoming data from the PC String sensorstring = \"\"; //a string to hold the data from the Atlas Scientific product boolean input_string_complete = false; //have we received all the data from the PC boolean sensor_string_complete = false; //have we received all the data from the Atlas Scientific product float pH; //used to hold a floating point number that is the pH void setup() { //set up the hardware Serial.begin(9600); //set baud rate for the hardware serial port_0 to 9600 myserial.begin(9600); //set baud rate for the software serial port to 9600 inputstring.reserve(10); //set aside some bytes for receiving data from the PC sensorstring.reserve(30); //set aside some bytes for receiving data from Atlas Scientific product } void serialEvent() { //if the hardware serial port_0 receives a char inputstring = Serial.readStringUntil(13); //read the string until we see a input_string_complete = true; //set the flag used to tell if we have received a completed string from the PC } void loop() { //here we go... if (input_string_complete == true) { //if a string from the PC has been received in its entirety myserial.print(inputstring); //send that string to the Atlas Scientific product myserial.print('\\r'); //add a to the end of the string inputstring = \"\"; //clear the string input_string_complete = false; //reset the flag used to tell if we have received a completed string from the PC } if (myserial.available() > 0) { //if we see that the Atlas Scientific product has sent a character char inchar = (char)myserial.read(); //get the char we just received sensorstring += inchar; //add the char to the var called sensorstring if (inchar == '\\r') { //if the incoming character is a sensor_string_complete = true; //set the flag } } if (sensor_string_complete == true) { //if a string from the Atlas Scientific product has been received in its entirety Serial.println(sensorstring); //send that string to the PC's serial monitor / //uncomment this section to see how to convert the pH reading from a string to a float if (isdigit(sensorstring[0])) { //if the first character in the string is a digit pH = sensorstring.toFloat(); //convert the string to a floating point number so it can be evaluated by the Arduino if (pH >= 7.0) { //if the pH is greater than or equal to 7.0 Serial.println(\"high\"); //print \"high\" this is demonstrating that the Arduino is evaluating the pH as a number and not as a string } if (pH <= 6.999) { //if the pH is less than or equal to 6.999 Serial.println(\"low\"); //print \"low\" this is demonstrating that the Arduino is evaluating the pH as a number and not as a string } } / sensorstring = \"\"; //clear the string sensor_string_complete = false; //reset the flag used to tell if we have received a completed string from the Atlas Scientific product } }","title":"define tx 3                                          //define what pin tx is going to be"},{"location":"src/hardware/ph-value/EZO-pH/#i2c","text":"//This code will work on an Arduino Uno and Mega //This code was written to be easy to understand. //Modify this code as you see fit. //This code will output data to the Arduino serial monitor. //Type commands into the Arduino serial monitor to control the Ph circuit. //This code was written in the Arduino 1.8.9 IDE //This code was last tested 7/2019","title":"I2C"},{"location":"src/hardware/ph-value/EZO-pH/#include-enable-i2c","text":"","title":"include                 //enable I2C."},{"location":"src/hardware/ph-value/EZO-pH/#define-address-99-default-i2c-id-number-for-ezo-ph-circuit","text":"char computerdata[20]; //we make a 20 byte character array to hold incoming data from a pc/mac/other. byte received_from_computer = 0; //we need to know how many characters have been received. byte serial_event = 0; //a flag to signal when data has been received from the pc/mac/other. byte code = 0; //used to hold the I2C response code. char ph_data[20]; //we make a 20 byte character array to hold incoming data from the pH circuit. byte in_char = 0; //used as a 1 byte buffer to store inbound bytes from the pH Circuit. byte i = 0; //counter used for ph_data array. int time_ = 815; //used to change the delay needed depending on the command sent to the EZO Class pH Circuit. float ph_float; //float var used to hold the float value of the pH. void setup() //hardware initialization. { Serial.begin(9600); //enable serial port. Wire.begin(); //enable I2C port. } void serialEvent() { //this interrupt will trigger when the data coming from the serial monitor(pc/mac/other) is received. received_from_computer = Serial.readBytesUntil(13, computerdata, 20); //we read the data sent from the serial monitor(pc/mac/other) until we see a . We also count how many characters have been received. computerdata[received_from_computer] = 0; //stop the buffer from transmitting leftovers or garbage. serial_event = true; //set the serial event flag. } void loop() { //the main loop. if (serial_event == true) { //if a command was sent to the EZO device. for (i = 0; i <= received_from_computer; i++) { //set all char to lower case, this is just so this exact sample code can recognize the \"sleep\" command. computerdata[i] = tolower(computerdata[i]); //\"Sleep\" \u2260 \"sleep\" } i=0; //reset i, we will need it later if (computerdata[0] == 'c' || computerdata[0] == 'r')time_ = 815; //if a command has been sent to calibrate or take a reading we wait 815ms so that the circuit has time to take the reading. else time_ = 250; //if any other command has been sent we wait only 250ms. Wire.beginTransmission(address); //call the circuit by its ID number. Wire.write(computerdata); //transmit the command that was sent through the serial port. Wire.endTransmission(); //end the I2C data transmission. if (strcmp(computerdata, \"sleep\") != 0) { //if the command that has been sent is NOT the sleep command, wait the correct amount of time and request data. //if it is the sleep command, we do nothing. Issuing a sleep command and then requesting data will wake the circuit. delay(time_); //wait the correct amount of time for the circuit to complete its instruction. Wire.requestFrom(address, 20, 1); //call the circuit and request 20 bytes (this may be more than we need) code = Wire.read(); //the first byte is the response code, we read this separately. switch (code) { //switch case based on what the response code is. case 1: //decimal 1. Serial.println(\"Success\"); //means the command was successful. break; //exits the switch case. case 2: //decimal 2. Serial.println(\"Failed\"); //means the command has failed. break; //exits the switch case. case 254: //decimal 254. Serial.println(\"Pending\"); //means the command has not yet been finished calculating. break; //exits the switch case. case 255: //decimal 255. Serial.println(\"No Data\"); //means there is no further data to send. break; //exits the switch case. } while (Wire.available()) { //are there bytes to receive. in_char = Wire.read(); //receive a byte. ph_data[i] = in_char; //load this byte into our array. i += 1; //incur the counter for the array element. if (in_char == 0) { //if we see that we have been sent a null command. i = 0; //reset the counter i to 0. break; //exit the while loop. } } Serial.println(ph_data); //print the data. } serial_event = false; //reset the serial event flag. } //Uncomment this section if you want to take the pH value and convert it into floating point number. //ph_float=atof(ph_data); }","title":"define address 99               //default I2C ID number for EZO pH Circuit."},{"location":"src/hardware/salt-content/xxx/","text":"Temperature and humidity Sensor DHT11 DHT11 Libraries Implementation","title":"Xxx"},{"location":"src/hardware/salt-content/xxx/#temperature-and-humidity-sensor-dht11","text":"","title":"Temperature and humidity Sensor DHT11"},{"location":"src/hardware/salt-content/xxx/#dht11","text":"","title":"DHT11"},{"location":"src/hardware/salt-content/xxx/#libraries","text":"","title":"Libraries"},{"location":"src/hardware/salt-content/xxx/#implementation","text":"","title":"Implementation"},{"location":"src/hardware/temperature-humidity/dht11/","text":"Temperature and humidity Sensor DHT11 DHT11 Ultra low cost 3 to 5V power and I/O 2.5mA max current use during conversion (while requesting data) Good for 20-80% humidity readings with 5% accuracy Good for 0-50\u00b0C temperature readings \u00b12\u00b0C accuracy No more than 1 Hz sampling rate (once every second) Body size 15.5mm x 12mm x 5.5mm 4 pins with 0.1\" spacing More information can be found here Libraries DHT.h Adafruit_Sensor.h Implementation To generate a DHT object it is necessary to specify the data Pin and wich sensor type is used. #define DHTPIN 0 #define DHTTYPE DHT11 DHT dht(DHTPIN, DHTTYPE); In the setup() it is necessary to call. dht.begin(); Now the temperature and humidity can be read by using: float temp = dht.readTemperature(); float humid = dht.readHumidity();","title":"DHT11"},{"location":"src/hardware/temperature-humidity/dht11/#temperature-and-humidity-sensor-dht11","text":"","title":"Temperature and humidity Sensor DHT11"},{"location":"src/hardware/temperature-humidity/dht11/#dht11","text":"Ultra low cost 3 to 5V power and I/O 2.5mA max current use during conversion (while requesting data) Good for 20-80% humidity readings with 5% accuracy Good for 0-50\u00b0C temperature readings \u00b12\u00b0C accuracy No more than 1 Hz sampling rate (once every second) Body size 15.5mm x 12mm x 5.5mm 4 pins with 0.1\" spacing More information can be found here","title":"DHT11"},{"location":"src/hardware/temperature-humidity/dht11/#libraries","text":"DHT.h Adafruit_Sensor.h","title":"Libraries"},{"location":"src/hardware/temperature-humidity/dht11/#implementation","text":"To generate a DHT object it is necessary to specify the data Pin and wich sensor type is used. #define DHTPIN 0 #define DHTTYPE DHT11 DHT dht(DHTPIN, DHTTYPE); In the setup() it is necessary to call. dht.begin(); Now the temperature and humidity can be read by using: float temp = dht.readTemperature(); float humid = dht.readHumidity();","title":"Implementation"},{"location":"src/hardware/temperature-humidity/soil-sensor/","text":"Adafruit Soil/Moisture Sensor Soil Sensor Ultra small Design Can be used with 3.3V or 5V logic level Cas used also with an Raspberry PI with Python No more than 1 Hz sampling rate (once every second) Body size: 16.5mm x 16.5mm x 2.1mm Got two mounting holes with a diameter of 2.5mm for M2.5 screws Communication Interface: I2C Capacitive measurement provides a range from 200(very dry) to 2000(very wet) provides also the ambient temperature on the \u00b5C, but not with a high precision (\u00b12\u00b0C) Includes an voltage regulator which provides 3.3V and 100mA 4 pins: Vin, GND, SCL, SDA Can be connected with a 4-pin JST-PH Connector More information can be found here Picture of the sensor Libraries \"Adafruit_seesaw.h\" Implementation Include Library for this sensor: #include \"Adafruit_seesaw.h\" Generate a new object: Adafruit_seesaw ss; Set the baud rate and check if a sensor is connected to the board: void setup() { Serial.begin(115200); Serial.println(\"seesaw Soil Sensor example!\"); if (!ss.begin(0x36)) { Serial.println(\"ERROR! seesaw not found\"); while(1); } else { Serial.print(\"seesaw started! version: \"); Serial.println(ss.getVersion(), HEX); } } Now the soil humidity can be reading by using: void loop() { float tempC = ss.getTemp(); uint16_t capread = ss.touchRead(0); The data will be printed on the Serial monitor: Serial.print(\"Temperature: \"); Serial.print(tempC); Serial.println(\"*C\"); Serial.print(\"Capacitive: \"); Serial.println(capread); delay(100); } How to connect the sensor on the Arduino","title":"Soil Sensor"},{"location":"src/hardware/temperature-humidity/soil-sensor/#soil-sensor","text":"Ultra small Design Can be used with 3.3V or 5V logic level Cas used also with an Raspberry PI with Python No more than 1 Hz sampling rate (once every second) Body size: 16.5mm x 16.5mm x 2.1mm Got two mounting holes with a diameter of 2.5mm for M2.5 screws Communication Interface: I2C Capacitive measurement provides a range from 200(very dry) to 2000(very wet) provides also the ambient temperature on the \u00b5C, but not with a high precision (\u00b12\u00b0C) Includes an voltage regulator which provides 3.3V and 100mA 4 pins: Vin, GND, SCL, SDA Can be connected with a 4-pin JST-PH Connector More information can be found here","title":"Soil Sensor"},{"location":"src/hardware/temperature-humidity/soil-sensor/#picture-of-the-sensor","text":"","title":"Picture of the sensor"},{"location":"src/hardware/temperature-humidity/soil-sensor/#libraries","text":"\"Adafruit_seesaw.h\"","title":"Libraries"},{"location":"src/hardware/temperature-humidity/soil-sensor/#implementation","text":"Include Library for this sensor: #include \"Adafruit_seesaw.h\" Generate a new object: Adafruit_seesaw ss; Set the baud rate and check if a sensor is connected to the board: void setup() { Serial.begin(115200); Serial.println(\"seesaw Soil Sensor example!\"); if (!ss.begin(0x36)) { Serial.println(\"ERROR! seesaw not found\"); while(1); } else { Serial.print(\"seesaw started! version: \"); Serial.println(ss.getVersion(), HEX); } } Now the soil humidity can be reading by using: void loop() { float tempC = ss.getTemp(); uint16_t capread = ss.touchRead(0); The data will be printed on the Serial monitor: Serial.print(\"Temperature: \"); Serial.print(tempC); Serial.println(\"*C\"); Serial.print(\"Capacitive: \"); Serial.println(capread); delay(100); }","title":"Implementation"},{"location":"src/hardware/temperature-humidity/soil-sensor/#how-to-connect-the-sensor-on-the-arduino","text":"","title":"How to connect the sensor on the Arduino"},{"location":"src/hardware/wind-velocity/Anemometer/","text":"Wind velocity Sensor with the Anemometer Anemometer Supply voltage 7-24VDC Output range from 0.4V(0 m/s) to 2V(32.4m/s) Height: 105mm Center out to Cup: 102mm Arm length: 70mm Weight: 111.8g 3 pins: brown(power), black(GND), blue(signal) Working ambient temperature: -20\u00b0C - +50\u00b0C Working ambeint humidity: 35% - 85% More information can be found here Can be ordered direct on the Adafruit homepage here Libraries Adafruit_GFX.h Adafruit_SSD1306.h Implementation Example Code #include <Adafruit_GFX.h> #include <Adafruit_SSD1306.h> #define SCREEN_WIDTH 128 // OLED display width, in pixels #define SCREEN_HEIGHT 64 // OLED display height, in pixels #define OLED_RESET 4 // Reset pin # (or -1 if sharing reset pin) Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET); void setup() { Serial.begin(9600); if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { Serial.println(F(\"SSD1306 allocation failed\")); for (;;); // Don't proceed, loop forever } display.display(); delay(100); display.clearDisplay(); display.clearDisplay(); display.setTextColor(WHITE); display.setTextSize(2); display.setCursor(0, 20); display.print(\"Anemometer\"); display.display(); delay(3000); } void loop() { float sensorValue = analogRead(A0); Serial.print(\"Analog Value =\"); Serial.println(sensorValue); float voltage = (sensorValue / 1023) * 5; Serial.print(\"Voltage =\"); Serial.print(voltage); Serial.println(\" V\"); float wind_speed = mapfloat(voltage, 0.4, 2, 0, 32.4); float speed_mph = ((wind_speed *3600)/1609.344); Serial.print(\"Wind Speed =\"); Serial.print(wind_speed); Serial.println(\"m/s\"); Serial.print(speed_mph); Serial.println(\"mph\"); display.clearDisplay(); display.setTextSize(1); display.setCursor(30, 0); display.println(\"Wind Speed\"); display.setTextSize(2); display.setCursor(25, 30); display.print(speed_mph, 1); display.setTextSize(1); display.print(\" mph\"); display.display(); Serial.println(\" \"); delay(300); } float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) { return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; } Picture of the sensor Example circuit","title":"Anemometer"},{"location":"src/hardware/wind-velocity/Anemometer/#wind-velocity-sensor-with-the-anemometer","text":"","title":"Wind velocity Sensor with the Anemometer"},{"location":"src/hardware/wind-velocity/Anemometer/#anemometer","text":"Supply voltage 7-24VDC Output range from 0.4V(0 m/s) to 2V(32.4m/s) Height: 105mm Center out to Cup: 102mm Arm length: 70mm Weight: 111.8g 3 pins: brown(power), black(GND), blue(signal) Working ambient temperature: -20\u00b0C - +50\u00b0C Working ambeint humidity: 35% - 85% More information can be found here Can be ordered direct on the Adafruit homepage here","title":"Anemometer"},{"location":"src/hardware/wind-velocity/Anemometer/#libraries","text":"Adafruit_GFX.h Adafruit_SSD1306.h","title":"Libraries"},{"location":"src/hardware/wind-velocity/Anemometer/#implementation","text":"","title":"Implementation"},{"location":"src/hardware/wind-velocity/Anemometer/#example-code","text":"#include <Adafruit_GFX.h> #include <Adafruit_SSD1306.h> #define SCREEN_WIDTH 128 // OLED display width, in pixels #define SCREEN_HEIGHT 64 // OLED display height, in pixels #define OLED_RESET 4 // Reset pin # (or -1 if sharing reset pin) Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET); void setup() { Serial.begin(9600); if (!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { Serial.println(F(\"SSD1306 allocation failed\")); for (;;); // Don't proceed, loop forever } display.display(); delay(100); display.clearDisplay(); display.clearDisplay(); display.setTextColor(WHITE); display.setTextSize(2); display.setCursor(0, 20); display.print(\"Anemometer\"); display.display(); delay(3000); } void loop() { float sensorValue = analogRead(A0); Serial.print(\"Analog Value =\"); Serial.println(sensorValue); float voltage = (sensorValue / 1023) * 5; Serial.print(\"Voltage =\"); Serial.print(voltage); Serial.println(\" V\"); float wind_speed = mapfloat(voltage, 0.4, 2, 0, 32.4); float speed_mph = ((wind_speed *3600)/1609.344); Serial.print(\"Wind Speed =\"); Serial.print(wind_speed); Serial.println(\"m/s\"); Serial.print(speed_mph); Serial.println(\"mph\"); display.clearDisplay(); display.setTextSize(1); display.setCursor(30, 0); display.println(\"Wind Speed\"); display.setTextSize(2); display.setCursor(25, 30); display.print(speed_mph, 1); display.setTextSize(1); display.print(\" mph\"); display.display(); Serial.println(\" \"); delay(300); } float mapfloat(float x, float in_min, float in_max, float out_min, float out_max) { return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min; }","title":"Example Code"},{"location":"src/hardware/wind-velocity/Anemometer/#picture-of-the-sensor","text":"","title":"Picture of the sensor"},{"location":"src/hardware/wind-velocity/Anemometer/#example-circuit","text":"","title":"Example circuit"},{"location":"tutorials/cpp-coding-style/","text":"Coding Style Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Here is a link for a more detailed dive into `c++ core guidelines' Style guide by the Barr Group: Style Guide Naming conventions Variables The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global/Local variables Global/Local variables should be defined in a snake_case style. Example: int global_variable ; Private variables Private variables should be defined the same way as global variables. The main difference for private variables is a defined prefix _ . Example: int _private_variable ; Constants & Preprocessor Values Constants are expression with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: const int PI_VALUE = 3.14159 ; Functions A function is a block of code which runs when it's called. Data in form of parameters can be passed into a function. Functions can be written as non-returning and returning type. Functions should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFunktion () { // do some stuff } Classes (Types, Template parameters) C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. In the example picture shown above, there is the class car defined, which has certain methods and attributes . This class can be used to create different objects which share the same set* of properties with different values. A class should be defined with all upper case (PascalCase) notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ) { brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int _current_speed ; }; void GeneralCar::setSpeed ( int new_speed ) { _current_speed = new_speed ; } int main () { // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; } Braces In order to get a clear structure the following braces scheme should be taking into account when programming. Every left brace ( { ) should be appear by itself on the line below it the block it opens. The corresponding right brace ( } ) should be placed by itself in the same position th appropriate number of lines later in the file. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; } else { car . price = \"low\" ; } The indentation should always be made with a tab . For every hierarchy step one tab has to be added. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; if ( car . weight >= 1000 ) { car . type = \"Truck\" ; } } else { car . price = \"low\" ; } Comments If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. For commenting block // should be used. ATTENTION Inline comments should be used with caution, because they can cause chaotic code. Example DON'T // divides up two double values double division ( double dividend , double divisor ) { // this is the result variable double div ; // the result is calculated here: div = dividend / divisor ; // here the result is given back return div ; } More to come here...","title":"C++"},{"location":"tutorials/cpp-coding-style/#coding-style","text":"Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Here is a link for a more detailed dive into `c++ core guidelines' Style guide by the Barr Group: Style Guide","title":"Coding Style"},{"location":"tutorials/cpp-coding-style/#naming-conventions","text":"","title":"Naming conventions"},{"location":"tutorials/cpp-coding-style/#variables","text":"The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global/Local variables Global/Local variables should be defined in a snake_case style. Example: int global_variable ; Private variables Private variables should be defined the same way as global variables. The main difference for private variables is a defined prefix _ . Example: int _private_variable ;","title":"Variables"},{"location":"tutorials/cpp-coding-style/#constants-preprocessor-values","text":"Constants are expression with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: const int PI_VALUE = 3.14159 ;","title":"Constants &amp; Preprocessor Values"},{"location":"tutorials/cpp-coding-style/#functions","text":"A function is a block of code which runs when it's called. Data in form of parameters can be passed into a function. Functions can be written as non-returning and returning type. Functions should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFunktion () { // do some stuff }","title":"Functions"},{"location":"tutorials/cpp-coding-style/#classes-types-template-parameters","text":"C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. In the example picture shown above, there is the class car defined, which has certain methods and attributes . This class can be used to create different objects which share the same set* of properties with different values. A class should be defined with all upper case (PascalCase) notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ) { brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int _current_speed ; }; void GeneralCar::setSpeed ( int new_speed ) { _current_speed = new_speed ; } int main () { // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; }","title":"Classes (Types, Template parameters)"},{"location":"tutorials/cpp-coding-style/#braces","text":"In order to get a clear structure the following braces scheme should be taking into account when programming. Every left brace ( { ) should be appear by itself on the line below it the block it opens. The corresponding right brace ( } ) should be placed by itself in the same position th appropriate number of lines later in the file. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; } else { car . price = \"low\" ; } The indentation should always be made with a tab . For every hierarchy step one tab has to be added. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; if ( car . weight >= 1000 ) { car . type = \"Truck\" ; } } else { car . price = \"low\" ; }","title":"Braces"},{"location":"tutorials/cpp-coding-style/#comments","text":"If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. For commenting block // should be used. ATTENTION Inline comments should be used with caution, because they can cause chaotic code. Example DON'T // divides up two double values double division ( double dividend , double divisor ) { // this is the result variable double div ; // the result is calculated here: div = dividend / divisor ; // here the result is given back return div ; } More to come here...","title":"Comments"},{"location":"tutorials/git-commit-style/","text":"Branching System Git in a nutshell! What is Git? Git is a Version Control System (VCS). With the utilization of Git the entire history of the project can be tracked. This means the VCS automatically tracks every minute change in the project and allows users to revert back to a previous version no matter how often the file got changed. Here is an Example GIT TREE The other main advantage is that Git allows people to work together seamlessly. With Git people can contribute onto the same project without disturbing each other's files. This allows team-members to work on different features within the project at the same time and easily merge changes together later on 1 . Basic terminology 1 Repository A Repository is a folder that is watched by Git. Here all file changes will be detected. A \"Repo\" builds up as the frame of everything Branch A Branch is an independent line of development. There will exists multiple branches within a Repo. Every Branch is its own working directory. Clone A clone is a simply copy of a repository that's downloaded and stored on the own computer. Commit A commit is a set of one ore more changes to a file (or a set of files). Every chang will create an unique ID (\"hash\") which helps keeping track of the history of the project. Master That's the default (initial) development branch. It's automatically created at the birth of the Repo. The master branch is usually used for merging the final result of a project together. For a more in-depth look have a look at the website: codeburst.io Basic Commands There are some basic commands that should be mastered right away when working with git . Clone With this command a repository with the suited link is cloned into the . directory. git clone <link> . Branch With this command all local pulled branches will be displayed in the shell. The current branch is marked in a certain color. git branch Switch Branches In order to switch different branches this command can be used git checkout <desired branch> Add This command is need to add new changes to a commit from the . directory. git add . Commit With this command the changes are ported to the repository and added to the version control git commit -m \"SUITABLE MESSAGE\" Push With this command the changes are uploaded to the remote repository git push Pull With this command new changes are downloaded to the local repository git pull Commit Style In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. f.e git commit -m \"ADD function XY()\" FIX Used for minor changes, bugfixes of an already existing part of the code. f.e git commit -m \"FIX functionality of XY\" REF Written short for: REFACTOR. Is used when there is a major change in multiple code-segments and the structure of the code is reworked. f.e git commit -m \"UPDATE setup of analog sensors\" Creating Pull Requests In order to keep the master branch clean and functioning the prototyping repository has a branch protection rule . When someone wants to merge code onto the master branche a pull request has to be made. The pull request informs the admin of the repository to have a look over the code in order to approve if this its functioning and good code which can be merged without hesitation. In order to understand how to create a pull request have a look here source: https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f \u21a9 \u21a9","title":"Git"},{"location":"tutorials/git-commit-style/#branching-system","text":"","title":"Branching System"},{"location":"tutorials/git-commit-style/#git-in-a-nutshell","text":"","title":"Git in a nutshell!"},{"location":"tutorials/git-commit-style/#what-is-git","text":"Git is a Version Control System (VCS). With the utilization of Git the entire history of the project can be tracked. This means the VCS automatically tracks every minute change in the project and allows users to revert back to a previous version no matter how often the file got changed. Here is an Example GIT TREE The other main advantage is that Git allows people to work together seamlessly. With Git people can contribute onto the same project without disturbing each other's files. This allows team-members to work on different features within the project at the same time and easily merge changes together later on 1 .","title":"What is Git?"},{"location":"tutorials/git-commit-style/#basic-terminology1","text":"Repository A Repository is a folder that is watched by Git. Here all file changes will be detected. A \"Repo\" builds up as the frame of everything Branch A Branch is an independent line of development. There will exists multiple branches within a Repo. Every Branch is its own working directory. Clone A clone is a simply copy of a repository that's downloaded and stored on the own computer. Commit A commit is a set of one ore more changes to a file (or a set of files). Every chang will create an unique ID (\"hash\") which helps keeping track of the history of the project. Master That's the default (initial) development branch. It's automatically created at the birth of the Repo. The master branch is usually used for merging the final result of a project together. For a more in-depth look have a look at the website: codeburst.io","title":"Basic terminology1"},{"location":"tutorials/git-commit-style/#basic-commands","text":"There are some basic commands that should be mastered right away when working with git . Clone With this command a repository with the suited link is cloned into the . directory. git clone <link> . Branch With this command all local pulled branches will be displayed in the shell. The current branch is marked in a certain color. git branch Switch Branches In order to switch different branches this command can be used git checkout <desired branch> Add This command is need to add new changes to a commit from the . directory. git add . Commit With this command the changes are ported to the repository and added to the version control git commit -m \"SUITABLE MESSAGE\" Push With this command the changes are uploaded to the remote repository git push Pull With this command new changes are downloaded to the local repository git pull","title":"Basic Commands"},{"location":"tutorials/git-commit-style/#commit-style","text":"In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. f.e git commit -m \"ADD function XY()\" FIX Used for minor changes, bugfixes of an already existing part of the code. f.e git commit -m \"FIX functionality of XY\" REF Written short for: REFACTOR. Is used when there is a major change in multiple code-segments and the structure of the code is reworked. f.e git commit -m \"UPDATE setup of analog sensors\"","title":"Commit Style"},{"location":"tutorials/git-commit-style/#creating-pull-requests","text":"In order to keep the master branch clean and functioning the prototyping repository has a branch protection rule . When someone wants to merge code onto the master branche a pull request has to be made. The pull request informs the admin of the repository to have a look over the code in order to approve if this its functioning and good code which can be merged without hesitation. In order to understand how to create a pull request have a look here source: https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f \u21a9 \u21a9","title":"Creating Pull Requests"},{"location":"tutorials/prototyping-guide/","text":"Prototyping Guide In order to create a good documentation the general setup of the file-tree has to be understood. Therefor the file-tree can be divided into two parts: PlatformIO Part Documentation Part PlatformIO The programming part is done in the tree part /src/ . Here the main.cpp file is stored on the top level. For every new category there should be a appropriate sub-file-tree where corresponding topics can be collected. As a starting example the directories /src/arduino-hardware/ , /src/arduino-iot-cloud/ and /src/aws/ have been created. For every new part of prototyping a suited folder in the example directories has to be created, eg. /src/aws/mqtt/ . All relevant files can be saved here ( .cpp , .hpp etc...). Documentation The documentation part ist done in the tree part /docs/src/ Here a mirror directory of the /src/ is created. That simplifies the overall visual structure. In the corresponding sub-folder , eg. /docs/src/aws/mqtt the necessary MARKDOWN .md needs to be stored. The Markdown file is used to record all necessary information about the finished prototyping.","title":"Prototyping Guide"},{"location":"tutorials/prototyping-guide/#prototyping-guide","text":"In order to create a good documentation the general setup of the file-tree has to be understood. Therefor the file-tree can be divided into two parts: PlatformIO Part Documentation Part","title":"Prototyping Guide"},{"location":"tutorials/prototyping-guide/#platformio","text":"The programming part is done in the tree part /src/ . Here the main.cpp file is stored on the top level. For every new category there should be a appropriate sub-file-tree where corresponding topics can be collected. As a starting example the directories /src/arduino-hardware/ , /src/arduino-iot-cloud/ and /src/aws/ have been created. For every new part of prototyping a suited folder in the example directories has to be created, eg. /src/aws/mqtt/ . All relevant files can be saved here ( .cpp , .hpp etc...).","title":"PlatformIO"},{"location":"tutorials/prototyping-guide/#documentation","text":"The documentation part ist done in the tree part /docs/src/ Here a mirror directory of the /src/ is created. That simplifies the overall visual structure. In the corresponding sub-folder , eg. /docs/src/aws/mqtt the necessary MARKDOWN .md needs to be stored. The Markdown file is used to record all necessary information about the finished prototyping.","title":"Documentation"}]}