{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Prototyping Documentation This documentations intention is to get a depth sight into everything discoverd while playing around with Arduinos, other microcontrollers and IoT Cloud Systems. For prototyping purposes a PlatformIO project has been created. The repository can be cloned by using the following link https://github.com/ECE-IoT/Prototyping.git Here is the: Prototyping Guide which helps to set up everything correctly. When everything is configured as shown, the documentation of the prototyping phase should be easy and intuitive.","title":"Home"},{"location":"#prototyping-documentation","text":"This documentations intention is to get a depth sight into everything discoverd while playing around with Arduinos, other microcontrollers and IoT Cloud Systems. For prototyping purposes a PlatformIO project has been created. The repository can be cloned by using the following link https://github.com/ECE-IoT/Prototyping.git Here is the: Prototyping Guide which helps to set up everything correctly. When everything is configured as shown, the documentation of the prototyping phase should be easy and intuitive.","title":"Prototyping Documentation"},{"location":"src/arduino/arduino-hardware/doc-ahw-temp-humid/","text":"Temperature and humidity Sensor DHT11 DHT11 Ultra low cost 3 to 5V power and I/O 2.5mA max current use during conversion (while requesting data) Good for 20-80% humidity readings with 5% accuracy Good for 0-50\u00b0C temperature readings \u00b12\u00b0C accuracy No more than 1 Hz sampling rate (once every second) Body size 15.5mm x 12mm x 5.5mm 4 pins with 0.1\" spacing More information can be found here Libraries DHT.h Adafruit_Sensor.h Implementation To generate a DHT object it is necessary to specify the data Pin and wich sensor type is used. #define DHTPIN 0 #define DHTTYPE DHT11 DHT dht(DHTPIN, DHTTYPE); In the setup() it is necessary to call. dht.begin(); Now the temperature and humidity can be read by using: float temp = dht.readTemperature(); float humid = dht.readHumidity();","title":"Temperature and humidity sensor DHT11"},{"location":"src/arduino/arduino-hardware/doc-ahw-temp-humid/#temperature-and-humidity-sensor-dht11","text":"","title":"Temperature and humidity Sensor DHT11"},{"location":"src/arduino/arduino-hardware/doc-ahw-temp-humid/#dht11","text":"Ultra low cost 3 to 5V power and I/O 2.5mA max current use during conversion (while requesting data) Good for 20-80% humidity readings with 5% accuracy Good for 0-50\u00b0C temperature readings \u00b12\u00b0C accuracy No more than 1 Hz sampling rate (once every second) Body size 15.5mm x 12mm x 5.5mm 4 pins with 0.1\" spacing More information can be found here","title":"DHT11"},{"location":"src/arduino/arduino-hardware/doc-ahw-temp-humid/#libraries","text":"DHT.h Adafruit_Sensor.h","title":"Libraries"},{"location":"src/arduino/arduino-hardware/doc-ahw-temp-humid/#implementation","text":"To generate a DHT object it is necessary to specify the data Pin and wich sensor type is used. #define DHTPIN 0 #define DHTTYPE DHT11 DHT dht(DHTPIN, DHTTYPE); In the setup() it is necessary to call. dht.begin(); Now the temperature and humidity can be read by using: float temp = dht.readTemperature(); float humid = dht.readHumidity();","title":"Implementation"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/","text":"Arduino IoT Cloud compatible boards Compatibel Arduino boards Currently (11/10/2021) the 9 official Arduino boards described below are compatible. Additionally many 3 rd party boards based on the ESP32 / ESP8266 are also compatible. MKR Wifi 1010 Connectivity: Wifi Special functions: Li-Po charging circuit, ECC508 crypto chip MKR Wifi 1000 Connectivity: Wifi, BLE Special functions: Li-Po charging circuit, ECC508 crypto chip Nano 33 IoT Connectivity: Wifi, BLE Special functions: IMU , ECC508 crypto chip, Cheapest Board! MKR WAN 1300 Connectivity: LoRa Special functions: low power consumption MKR WAN 1310 Connectivity: LoRa Special functions: low power consumption, ECC508 crypto chip MKR GSM 1400 Connectivity: GSM / 3G Special functions: Li-Po charging circuit, ECC508 crypto chip MKR NB 1500 Connectivity: NB LTE Special functions: low power consumption, Li-Po charging circuit, ECC508 crypto chip Nano RP2040 Connect Connectivity: Wifi, BLE Special functions: based on the Raspberry Pi RP2040, Microphone, IMU , ECC608 crypto chip, Micropyhton support Portenta H7 Connectivity: Wifi, BLE, Ethernet, Displayport output over USB-C Special functions: on board GPU, Li-Po charging circuit, generally for high level code with realtime taks, NXP SE050C2 crypto chip, Micropyhton support Compatible Linux devices The following Linux devices are supported: Arduino Pro Gateway Intel\u00ae-based platforms IEI TANK AIoT Dev Kit Arm\u00ae-based platforms Raspberry Pi BeagleBone UP Squared AI Vision Kit UP Squared Grove IoT Development Kit More Information Overview of supportet devices About python on the Arduino. About Low-Power Wan. About to setup up a Linux device Source of information This description ist mainly based on the linked websites and further information to the boards can also be found there.","title":"Compatible boards"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/#arduino-iot-cloud-compatible-boards","text":"","title":"Arduino IoT Cloud compatible boards"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/#compatibel-arduino-boards","text":"Currently (11/10/2021) the 9 official Arduino boards described below are compatible. Additionally many 3 rd party boards based on the ESP32 / ESP8266 are also compatible. MKR Wifi 1010 Connectivity: Wifi Special functions: Li-Po charging circuit, ECC508 crypto chip MKR Wifi 1000 Connectivity: Wifi, BLE Special functions: Li-Po charging circuit, ECC508 crypto chip Nano 33 IoT Connectivity: Wifi, BLE Special functions: IMU , ECC508 crypto chip, Cheapest Board! MKR WAN 1300 Connectivity: LoRa Special functions: low power consumption MKR WAN 1310 Connectivity: LoRa Special functions: low power consumption, ECC508 crypto chip MKR GSM 1400 Connectivity: GSM / 3G Special functions: Li-Po charging circuit, ECC508 crypto chip MKR NB 1500 Connectivity: NB LTE Special functions: low power consumption, Li-Po charging circuit, ECC508 crypto chip Nano RP2040 Connect Connectivity: Wifi, BLE Special functions: based on the Raspberry Pi RP2040, Microphone, IMU , ECC608 crypto chip, Micropyhton support Portenta H7 Connectivity: Wifi, BLE, Ethernet, Displayport output over USB-C Special functions: on board GPU, Li-Po charging circuit, generally for high level code with realtime taks, NXP SE050C2 crypto chip, Micropyhton support","title":"Compatibel Arduino boards"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/#compatible-linux-devices","text":"The following Linux devices are supported: Arduino Pro Gateway Intel\u00ae-based platforms IEI TANK AIoT Dev Kit Arm\u00ae-based platforms Raspberry Pi BeagleBone UP Squared AI Vision Kit UP Squared Grove IoT Development Kit","title":"Compatible Linux devices"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/#more-information","text":"Overview of supportet devices About python on the Arduino. About Low-Power Wan. About to setup up a Linux device","title":"More Information"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-boards/#source-of-information","text":"This description ist mainly based on the linked websites and further information to the boards can also be found there.","title":"Source of information"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/","text":"Arduino IoT Cloud example About the example. The goal of this application is to measure temperature and humidity with an Arduino mkr 1010 board, periodically transfer the measured values to the cloud and display them on a dashboard. There is also an LED connected to the Arduino that can be turned on and off with a button on the dashboard. Implementation Config at AIC I created an thing named example_aplication . The thing contains three variables. Two float read only variables (mkr1010_humid and mkr1010_temp) to get temperature and humidity values. These two variables are automatically updated to the cloud every second. The thrid variable is a bool read and write variable (mkr1010_led). It is used to control the connected LED and is updated when the variable is changed on the device or in the AIC. Furthermore, the device (Arduino mkr 1010) had to be added and the network information had to be specified. Generated Sketch All configuration was done on the AIC website and the sketch file was created automatically. I downloaded the sketch and edited it witch PlatformIO. Steps involved to do that are described here . Besides the main code wiht a setup() and void() the sketch also includes the files thingProperties.h and arduino_secrets.h. thingProperties.h In that generated file is the configuration for the created variables and the wifi connection. I removed the thing id, but you cant find it in the sharpoint fodler under \"Dateien\\Administration\\Arduino IoT Cloud\\Wifi and thing id.txt\" #include \"ArduinoIoTCloud.h\" #include \"Arduino_ConnectionHandler.h\" #include \"arduino_secrets.h\" const char THING_ID[] = \"enter thing ID\"; const char SSID[] = SECRET_SSID; // Network SSID (name) const char PASS[] = SECRET_PASS; // Network password (use for WPA, or use as key for WEP) void onMkr1010LedChange(); float mkr1010_humid; bool mkr1010_led; float mkr1010_temp; void initProperties() { ArduinoCloud.setThingId(THING_ID); ArduinoCloud.addProperty(mkr1010_humid, READ, 1 * SECONDS, NULL); ArduinoCloud.addProperty(mkr1010_led, READWRITE, ON_CHANGE, onMkr1010LedChange); ArduinoCloud.addProperty(mkr1010_temp, READ, 1 * SECONDS, NULL); } WiFiConnectionHandler ArduinoIoTPreferredConnection(SSID, PASS); arduino_secrets.h This file cotains the network information. At the Fh we can use the ECEmbedded network. The related information can be found in the sharpoint fodler under \"Dateien\\Administration\\Arduino IoT Cloud\\Wifi and thing id.txt\" #define SECRET_SSID \"enter ssid\" #define SECRET_PASS \"enter password\" main Originally a main was created with the following structure. #include <Arduino.h> #include \"arduino_secrets.h\" #include \"thingProperties.h\" setup() { // Initialize serial and wait for port to open: Serial.begin(9600); // This delay gives the chance to wait for a Serial Monitor without blocking if none is found delay(1500); // Defined in thingProperties.h initProperties(); // Connect to Arduino IoT Cloud ArduinoCloud.begin(ArduinoIoTPreferredConnection); /* The following function allows you to obtain more information related to the state of network and IoT Cloud connection and errors the higher number the more granular information you\u2019ll get. The default is 0 (only errors). Maximum is 4 */ setDebugMessageLevel(2); ArduinoCloud.printDebugInfo(); } loop() { ArduinoCloud.update(); } void onMkr1010LedChange() { } Most of the code is self-explanatory. The function ArduinoCloud.update(); is used to reset the Watchdogtimer frequently. The purpose of the Watchdog is to restart the arduino when it does not work corectly. To detect this the watchdog counts down from a certain number and when zero is reached it detects an error and resets the arduino. Therefore the timer must be reset often. The function onMkr1010LedChange() is called from the AIC when a value change of the mkr1010_led variable happend. Implementation of the measurement and the LED. The code to measure temperature and humidity and the sensor is described here . This code is used in the main. An example how to controll an LED can be found here . More changes I have adapted the main of the example so that by inserting the functions example_setup() example_loop() the program is executed. You can add the following code to your main.cpp in the src folder and it should work. #include <arduino.h> #include \"aic_example/example_main.hpp\" void setup() { example_setup(); } void loop() { example_loop(); } Necessary libraries ArduinoIoTCloud.h Arduino_ConnectionHandler.h Adafruit_Sensor.h DHT.h Add the following code to your libraries, if not already present. lib_deps = adafruit/DHT sensor library@^1.4.2 adafruit/Adafruit Unified Sensor@^1.1.4 arduino-libraries/ArduinoIoTCloud@^1.2.1 arduino-libraries/Arduino_ConnectionHandler@^0.6.4 How to connect the sensor and the LED In the example the LED is vonnect at pin 1 and the data output of the DHT11 is connected to pin 0. I used a 220 Ohm resistor for the LED circuit. Dashboard On the aic website, under dashboards, you will find a large number of widgets that you can simply click together and connect to the variables. I have clicked a few together. This dashboard can be viewed on the website or in the AIC app. More information More information (e.g. login to AIC, getting started with AIC) can be found here .","title":"Example"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#arduino-iot-cloud-example","text":"","title":"Arduino IoT Cloud example"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#about-the-example","text":"The goal of this application is to measure temperature and humidity with an Arduino mkr 1010 board, periodically transfer the measured values to the cloud and display them on a dashboard. There is also an LED connected to the Arduino that can be turned on and off with a button on the dashboard.","title":"About the example."},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#implementation","text":"","title":"Implementation"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#config-at-aic","text":"I created an thing named example_aplication . The thing contains three variables. Two float read only variables (mkr1010_humid and mkr1010_temp) to get temperature and humidity values. These two variables are automatically updated to the cloud every second. The thrid variable is a bool read and write variable (mkr1010_led). It is used to control the connected LED and is updated when the variable is changed on the device or in the AIC. Furthermore, the device (Arduino mkr 1010) had to be added and the network information had to be specified.","title":"Config at AIC"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#generated-sketch","text":"All configuration was done on the AIC website and the sketch file was created automatically. I downloaded the sketch and edited it witch PlatformIO. Steps involved to do that are described here . Besides the main code wiht a setup() and void() the sketch also includes the files thingProperties.h and arduino_secrets.h. thingProperties.h In that generated file is the configuration for the created variables and the wifi connection. I removed the thing id, but you cant find it in the sharpoint fodler under \"Dateien\\Administration\\Arduino IoT Cloud\\Wifi and thing id.txt\" #include \"ArduinoIoTCloud.h\" #include \"Arduino_ConnectionHandler.h\" #include \"arduino_secrets.h\" const char THING_ID[] = \"enter thing ID\"; const char SSID[] = SECRET_SSID; // Network SSID (name) const char PASS[] = SECRET_PASS; // Network password (use for WPA, or use as key for WEP) void onMkr1010LedChange(); float mkr1010_humid; bool mkr1010_led; float mkr1010_temp; void initProperties() { ArduinoCloud.setThingId(THING_ID); ArduinoCloud.addProperty(mkr1010_humid, READ, 1 * SECONDS, NULL); ArduinoCloud.addProperty(mkr1010_led, READWRITE, ON_CHANGE, onMkr1010LedChange); ArduinoCloud.addProperty(mkr1010_temp, READ, 1 * SECONDS, NULL); } WiFiConnectionHandler ArduinoIoTPreferredConnection(SSID, PASS); arduino_secrets.h This file cotains the network information. At the Fh we can use the ECEmbedded network. The related information can be found in the sharpoint fodler under \"Dateien\\Administration\\Arduino IoT Cloud\\Wifi and thing id.txt\" #define SECRET_SSID \"enter ssid\" #define SECRET_PASS \"enter password\" main Originally a main was created with the following structure. #include <Arduino.h> #include \"arduino_secrets.h\" #include \"thingProperties.h\" setup() { // Initialize serial and wait for port to open: Serial.begin(9600); // This delay gives the chance to wait for a Serial Monitor without blocking if none is found delay(1500); // Defined in thingProperties.h initProperties(); // Connect to Arduino IoT Cloud ArduinoCloud.begin(ArduinoIoTPreferredConnection); /* The following function allows you to obtain more information related to the state of network and IoT Cloud connection and errors the higher number the more granular information you\u2019ll get. The default is 0 (only errors). Maximum is 4 */ setDebugMessageLevel(2); ArduinoCloud.printDebugInfo(); } loop() { ArduinoCloud.update(); } void onMkr1010LedChange() { } Most of the code is self-explanatory. The function ArduinoCloud.update(); is used to reset the Watchdogtimer frequently. The purpose of the Watchdog is to restart the arduino when it does not work corectly. To detect this the watchdog counts down from a certain number and when zero is reached it detects an error and resets the arduino. Therefore the timer must be reset often. The function onMkr1010LedChange() is called from the AIC when a value change of the mkr1010_led variable happend.","title":"Generated Sketch"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#implementation-of-the-measurement-and-the-led","text":"The code to measure temperature and humidity and the sensor is described here . This code is used in the main. An example how to controll an LED can be found here . More changes I have adapted the main of the example so that by inserting the functions example_setup() example_loop() the program is executed. You can add the following code to your main.cpp in the src folder and it should work. #include <arduino.h> #include \"aic_example/example_main.hpp\" void setup() { example_setup(); } void loop() { example_loop(); } Necessary libraries ArduinoIoTCloud.h Arduino_ConnectionHandler.h Adafruit_Sensor.h DHT.h Add the following code to your libraries, if not already present. lib_deps = adafruit/DHT sensor library@^1.4.2 adafruit/Adafruit Unified Sensor@^1.1.4 arduino-libraries/ArduinoIoTCloud@^1.2.1 arduino-libraries/Arduino_ConnectionHandler@^0.6.4","title":"Implementation of the measurement and the LED."},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#how-to-connect-the-sensor-and-the-led","text":"In the example the LED is vonnect at pin 1 and the data output of the DHT11 is connected to pin 0. I used a 220 Ohm resistor for the LED circuit.","title":"How to connect the sensor and the LED"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#dashboard","text":"On the aic website, under dashboards, you will find a large number of widgets that you can simply click together and connect to the variables. I have clicked a few together. This dashboard can be viewed on the website or in the AIC app.","title":"Dashboard"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-example/#more-information","text":"More information (e.g. login to AIC, getting started with AIC) can be found here .","title":"More information"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/","text":"Getting started General preperations Create Agent If you plan to use the Arduino web editor you have to install the Arduino create agent. (Can be found here ). It provides the functionality for the web editor to detect Arduino boards and other supported devices connected to the computer via USB, upload sketches and use the serial monitor. Note: Alternatively, PlatformIO can be used for programming. No create agent is required for PlatformIO. Access the AIC Access AIC from any page on arduino.cc by clicking on the bento menu (9-dots) on the top right corner, or you can go directly to AIC. Login An AIC account has already been created for the project group. The login informations can be found under Dateien\\Administration\\Arduino IoT Cloud\\Zugang.docx in the share point folder. Creating a Thing A new project starts by creating a new Ting. We need to add a device by clicking on the \"Select device\" button on the Thing overview. Here, we choose from any board that we have already been configured, or select the Configure new device option. You can find a list of compatible boards here . Next we can add a variable by clicking on the Add variable button. We can choose name, data type, update the setting and interaction mode for our variable. There are several data types we can choose from, such as int, float, boolean, long, char. There\u2019s also special variables, such as Temperature, Velocity, and Luminance that can be used. Finally, we need to connect to a Wi-Fi network by simply clicking the Configure button in the network section. Enter your network credentials and click Save. This information will also be generated into your sketch file! At the FH we can use the ECEmbedded Wi-Fi network. The Login information can be found in the students room. Building a Sketch A special sketch file can now be found in the Sketch tab, which includes all of the configurations that you have made. When the sketch has been uploaded, it will work as a regular sketch, but it will also update the Cloud variables that we use! Additionally, each time we create a variable that has the Interaction Mode enabled, a function will also be generated. Every time this variable is triggered from the Cloud, it will execute the code within this function! This means that we can leave most of the code out of the loop() and only run code when needed. How to use PlatformIO for the project? The sketch can be editet with the web editor or you can download the sketch and use PlatformIO. PlatformIO provides the function Import Arduino Project wich can be found at the main page of the PlatformIO Gui. In the Web Editor, the included libraries are automatically added to the project during compilation. At PlatformIO we have to add libraries at the .ini file with lib_deps . The libraries specified with lib_deps are automatically downloaded when the code is compiled. The PlatformIO Gui provides under the tab Libraries a function to search and add libraries to a project. Example: lib_deps = adafruit/DHT sensor library@^1.4.2 adafruit/Adafruit Unified Sensor@^1.1.4 arduino-libraries/ArduinoIoTCloud@^1.2.1 arduino-libraries/Arduino_ConnectionHandler@^0.6.4 The advanteg of these library management ist that we can decide wihch version is supposed to be used. This should prevent us from getting into trouble by using different library versions. Creating the dashboard Dashboards are visual user interfaces for interacting with your boards over the Cloud, and we can set up many different setups depending on what your IoT project needs. We can access our dashboards by clicking on the Dashboards tab at the top of the Arduino IoT Cloud interface, where we can create new dashboards, and see a list of dashboards created for other Things. If we click on Create new dashboard, we enter a dashboard editor. Here, we can create something called widgets. Widgets are the visual representation of our variables we create. When we create widgets, we also need to link them to our variables. This is done by clicking on a widget we create, selecting a Thing, and selecting a variable that we want to link. Once it is linked, we can either interact with it, for example a button, or we can monitor a value from a sensor. As long as our board is connected to the cloud, the values will update automatically! The dashboards can be accessed at the AIC website ore with the AIC App. Detailed description of the therminology used Abbreviations Arduinot IoT Cloud = AIC Devices Physical objects built around a board (e.g. MKR WiFi 1010). This is the hardware which runs the sketch, reads sensors, controls actuators and communicates with the Arduino IoT Cloud. Things Logical representation of a connected object. They embody inherent properties of the object, with as little reference to the actual hardware or code used to implement them. Each Thing is represented by a collection of Properties (e.g., temperature, light, pressure...). Properties Qualities defining the characteristics of a system. A Property can be defined as read-only (READ) to indicate that Arduino IoT Cloud can read the data, but cannot change the value of such Property. On the other end, it may be designated to be read-and-write (READWRITE), allowing Arduino IoT Cloud to remotely change the property\u2019s value and trigger an event notification on the device. It is also possible to mark properties as write-only (WRITE) which means the cloud can write to this property but not read its value (this limits data transmission for properties which are used to trigger events only). Source of information This description ist mainly based on the following sources: An intro to the Arduino IoT Cloud from Arduino Docs. Arduino IoT Cloud library Github documentation.","title":"Getting started"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#getting-started","text":"","title":"Getting started"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#general-preperations","text":"Create Agent If you plan to use the Arduino web editor you have to install the Arduino create agent. (Can be found here ). It provides the functionality for the web editor to detect Arduino boards and other supported devices connected to the computer via USB, upload sketches and use the serial monitor. Note: Alternatively, PlatformIO can be used for programming. No create agent is required for PlatformIO. Access the AIC Access AIC from any page on arduino.cc by clicking on the bento menu (9-dots) on the top right corner, or you can go directly to AIC. Login An AIC account has already been created for the project group. The login informations can be found under Dateien\\Administration\\Arduino IoT Cloud\\Zugang.docx in the share point folder.","title":"General preperations"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#creating-a-thing","text":"A new project starts by creating a new Ting. We need to add a device by clicking on the \"Select device\" button on the Thing overview. Here, we choose from any board that we have already been configured, or select the Configure new device option. You can find a list of compatible boards here . Next we can add a variable by clicking on the Add variable button. We can choose name, data type, update the setting and interaction mode for our variable. There are several data types we can choose from, such as int, float, boolean, long, char. There\u2019s also special variables, such as Temperature, Velocity, and Luminance that can be used. Finally, we need to connect to a Wi-Fi network by simply clicking the Configure button in the network section. Enter your network credentials and click Save. This information will also be generated into your sketch file! At the FH we can use the ECEmbedded Wi-Fi network. The Login information can be found in the students room.","title":"Creating a Thing"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#building-a-sketch","text":"A special sketch file can now be found in the Sketch tab, which includes all of the configurations that you have made. When the sketch has been uploaded, it will work as a regular sketch, but it will also update the Cloud variables that we use! Additionally, each time we create a variable that has the Interaction Mode enabled, a function will also be generated. Every time this variable is triggered from the Cloud, it will execute the code within this function! This means that we can leave most of the code out of the loop() and only run code when needed.","title":"Building a Sketch"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#how-to-use-platformio-for-the-project","text":"The sketch can be editet with the web editor or you can download the sketch and use PlatformIO. PlatformIO provides the function Import Arduino Project wich can be found at the main page of the PlatformIO Gui. In the Web Editor, the included libraries are automatically added to the project during compilation. At PlatformIO we have to add libraries at the .ini file with lib_deps . The libraries specified with lib_deps are automatically downloaded when the code is compiled. The PlatformIO Gui provides under the tab Libraries a function to search and add libraries to a project. Example: lib_deps = adafruit/DHT sensor library@^1.4.2 adafruit/Adafruit Unified Sensor@^1.1.4 arduino-libraries/ArduinoIoTCloud@^1.2.1 arduino-libraries/Arduino_ConnectionHandler@^0.6.4 The advanteg of these library management ist that we can decide wihch version is supposed to be used. This should prevent us from getting into trouble by using different library versions.","title":"How to use PlatformIO for the project?"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#creating-the-dashboard","text":"Dashboards are visual user interfaces for interacting with your boards over the Cloud, and we can set up many different setups depending on what your IoT project needs. We can access our dashboards by clicking on the Dashboards tab at the top of the Arduino IoT Cloud interface, where we can create new dashboards, and see a list of dashboards created for other Things. If we click on Create new dashboard, we enter a dashboard editor. Here, we can create something called widgets. Widgets are the visual representation of our variables we create. When we create widgets, we also need to link them to our variables. This is done by clicking on a widget we create, selecting a Thing, and selecting a variable that we want to link. Once it is linked, we can either interact with it, for example a button, or we can monitor a value from a sensor. As long as our board is connected to the cloud, the values will update automatically! The dashboards can be accessed at the AIC website ore with the AIC App.","title":"Creating the dashboard"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#detailed-description-of-the-therminology-used","text":"Abbreviations Arduinot IoT Cloud = AIC Devices Physical objects built around a board (e.g. MKR WiFi 1010). This is the hardware which runs the sketch, reads sensors, controls actuators and communicates with the Arduino IoT Cloud. Things Logical representation of a connected object. They embody inherent properties of the object, with as little reference to the actual hardware or code used to implement them. Each Thing is represented by a collection of Properties (e.g., temperature, light, pressure...). Properties Qualities defining the characteristics of a system. A Property can be defined as read-only (READ) to indicate that Arduino IoT Cloud can read the data, but cannot change the value of such Property. On the other end, it may be designated to be read-and-write (READWRITE), allowing Arduino IoT Cloud to remotely change the property\u2019s value and trigger an event notification on the device. It is also possible to mark properties as write-only (WRITE) which means the cloud can write to this property but not read its value (this limits data transmission for properties which are used to trigger events only).","title":"Detailed description of the therminology used"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-getting-started/#source-of-information","text":"This description ist mainly based on the following sources: An intro to the Arduino IoT Cloud from Arduino Docs. Arduino IoT Cloud library Github documentation.","title":"Source of information"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/","text":"Arduino IoT Cloud overview Concept In the beginning a thing is created. A device is assigned to it. For a thing, several variables can be created, which can have different functionalities and are automatically synchronized with the device. Furthermore, network information must be specified. From this information, a code is automatically generated, which does all the work for the user. The user now only has to insert his own code (e.g. read temperature sensor) and all the work around has already been done automatically. The AIC and the whole process seems to me that it is actually what should come out of our project. Web editor It is possible to edit, compile and load code on devices with this editor. Pros: - Included libraries are automatically found during compiling. - Code is automatically saved in the cloud. Cons: - The code is compiled on Arduino servers, which takes more time than compiling with PLatformIO on my PC. - Git can not be used In my opinion not interesting for our applications. Dashboard The AIC provides a set of widgets to display and control the variables of a thing. The dashboard can be accessed through the AIC website and the AIC App. Libraries The following two libraries are central to using a device with the AIC. ArduinoIoTCloud The ArduinoIoTCloud library is the central element of the firmware enabling certain Arduino boards to connect to the Arduino IoT Cloud. Arduino_ConnectionHandler Library for handling and managing network connections by providing keep-alive functionality and automatic reconnection in case of connection-loss. Further descriptions will follow soon. API Provides a set of endpoints to manage Arduino IoT Cloud Devices, Things, Properties and Timeseries. This API can be called just with any HTTP Client, or using one of these clients: Javascript NPM package Python PYPI Package Golang Module Not tested anything yet. Security All IoT device communications to the cloud use the industry standard SSL protocol for encryption. Arduino MKR and Arduino Portenta board families have on-board crypto-authentication chips and are further secured using X.509 certificate-based authentication. further research necessary. What exactly is the crypto authentication chip used for? Open questions How exactly is the communication AIC - Device and Decive - Device implementet? Somehow with mqtt. How god does the API work? What exactly is the crypto authentication chip used for? Source of information This description ist mainly based on the following sources:","title":"Overview"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#arduino-iot-cloud-overview","text":"","title":"Arduino IoT Cloud overview"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#concept","text":"In the beginning a thing is created. A device is assigned to it. For a thing, several variables can be created, which can have different functionalities and are automatically synchronized with the device. Furthermore, network information must be specified. From this information, a code is automatically generated, which does all the work for the user. The user now only has to insert his own code (e.g. read temperature sensor) and all the work around has already been done automatically. The AIC and the whole process seems to me that it is actually what should come out of our project.","title":"Concept"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#web-editor","text":"It is possible to edit, compile and load code on devices with this editor. Pros: - Included libraries are automatically found during compiling. - Code is automatically saved in the cloud. Cons: - The code is compiled on Arduino servers, which takes more time than compiling with PLatformIO on my PC. - Git can not be used In my opinion not interesting for our applications.","title":"Web editor"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#dashboard","text":"The AIC provides a set of widgets to display and control the variables of a thing. The dashboard can be accessed through the AIC website and the AIC App.","title":"Dashboard"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#libraries","text":"The following two libraries are central to using a device with the AIC. ArduinoIoTCloud The ArduinoIoTCloud library is the central element of the firmware enabling certain Arduino boards to connect to the Arduino IoT Cloud. Arduino_ConnectionHandler Library for handling and managing network connections by providing keep-alive functionality and automatic reconnection in case of connection-loss. Further descriptions will follow soon.","title":"Libraries"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#api","text":"Provides a set of endpoints to manage Arduino IoT Cloud Devices, Things, Properties and Timeseries. This API can be called just with any HTTP Client, or using one of these clients: Javascript NPM package Python PYPI Package Golang Module Not tested anything yet.","title":"API"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#security","text":"All IoT device communications to the cloud use the industry standard SSL protocol for encryption. Arduino MKR and Arduino Portenta board families have on-board crypto-authentication chips and are further secured using X.509 certificate-based authentication. further research necessary. What exactly is the crypto authentication chip used for?","title":"Security"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#open-questions","text":"How exactly is the communication AIC - Device and Decive - Device implementet? Somehow with mqtt. How god does the API work? What exactly is the crypto authentication chip used for?","title":"Open questions"},{"location":"src/arduino/arduino-iot-cloud/doc-aic-overview/#source-of-information","text":"This description ist mainly based on the following sources:","title":"Source of information"},{"location":"src/aws/aws-cli/","text":"Command Line Interface The AWS CLI is an open source tool that enables the user to interact with AWS services using commands in the command-line shell. With the CLI basic functionality can be implemented and maintained. Link to the docs The CLI can be used in the Linux shell , in the Windows command line and Remotely . There are different AWS CLI versions. The one used for ECE IoT Prototyping is Version 2.x . Installation The installations is described excellently in the AWS DOCS Linux installation macOS installation Windows installation Tip Have a look here in order to understand what a CLI is!","title":"CLI"},{"location":"src/aws/aws-cli/#command-line-interface","text":"The AWS CLI is an open source tool that enables the user to interact with AWS services using commands in the command-line shell. With the CLI basic functionality can be implemented and maintained. Link to the docs The CLI can be used in the Linux shell , in the Windows command line and Remotely . There are different AWS CLI versions. The one used for ECE IoT Prototyping is Version 2.x .","title":"Command Line Interface"},{"location":"src/aws/aws-cli/#installation","text":"The installations is described excellently in the AWS DOCS Linux installation macOS installation Windows installation Tip Have a look here in order to understand what a CLI is!","title":"Installation"},{"location":"src/aws/aws-iam/","text":"Identity and Access Management IAM is a web service that helps to securely control access to AWS resources. In order to operate securely when handling with multiple developers, projects a good access hierarchy is compulsory. Link to the docs Users Root When creating a AWS account the first user is the root user, which owns the account, has all access rights. This account provides the billing information, has the ability to change the password of all other sub-users . This level of access can be dangerous when handling with lower-level tasks, so it's recommended to not use the root user credentials for everyday development/access. Administrator The Administrator user has almost the same access rights as the root. The biggest exception is that the Administrator is not the owner of the account. An Administrator can be used for managing the rest of the Accounts with a extra level of security. Developer Multiple developer accounts can be created. They do have access to the certain resource in which they are building the desired Application. Groups and Policies Summed up, those two sections are used to an easier management of different resource distribution. Warning This summary is only a rough overview of the complex functionality of AWS IAM. In order to get a deeper understanding reading the docs is mandatory!","title":"Identity and Access Management"},{"location":"src/aws/aws-iam/#identity-and-access-management","text":"IAM is a web service that helps to securely control access to AWS resources. In order to operate securely when handling with multiple developers, projects a good access hierarchy is compulsory. Link to the docs","title":"Identity and Access Management"},{"location":"src/aws/aws-iam/#users","text":"","title":"Users"},{"location":"src/aws/aws-iam/#root","text":"When creating a AWS account the first user is the root user, which owns the account, has all access rights. This account provides the billing information, has the ability to change the password of all other sub-users . This level of access can be dangerous when handling with lower-level tasks, so it's recommended to not use the root user credentials for everyday development/access.","title":"Root"},{"location":"src/aws/aws-iam/#administrator","text":"The Administrator user has almost the same access rights as the root. The biggest exception is that the Administrator is not the owner of the account. An Administrator can be used for managing the rest of the Accounts with a extra level of security.","title":"Administrator"},{"location":"src/aws/aws-iam/#developer","text":"Multiple developer accounts can be created. They do have access to the certain resource in which they are building the desired Application.","title":"Developer"},{"location":"src/aws/aws-iam/#groups-and-policies","text":"Summed up, those two sections are used to an easier management of different resource distribution. Warning This summary is only a rough overview of the complex functionality of AWS IAM. In order to get a deeper understanding reading the docs is mandatory!","title":"Groups and Policies"},{"location":"tutorials/cpp-coding-style/","text":"Coding Style Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Here is a link for a more detailed dive into `c++ core guidelines' Style guide by the Barr Group: Style Guide Naming conventions Variables The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global/Local variables Global/Local variables should be defined in a snake_case style. Example: int global_variable ; Private variables Private variables should be defined the same way as global variables. The main difference for private variables is a defined prefix _ . Example: int _private_variable ; Constants & Preprocessor Values Constants are expression with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: const int PI_VALUE = 3.14159 ; Functions A function is a block of code which runs when it's called. Data in form of parameters can be passed into a function. Functions can be written as non-returning and returning type. Functions should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFunktion () { // do some stuff } Classes (Types, Template parameters) C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. In the example picture shown above, there is the class car defined, which has certain methods and attributes . This class can be used to create different objects which share the same set* of properties with different values. A class should be defined with all upper case (PascalCase) notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ) { brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int _current_speed ; }; void GeneralCar::setSpeed ( int new_speed ) { _current_speed = new_speed ; } int main () { // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; } Braces In order to get a clear structure the following braces scheme should be taking into account when programming. Every left brace ( { ) should be appear by itself on the line below it the block it opens. The corresponding right brace ( } ) should be placed by itself in the same position th appropriate number of lines later in the file. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; } else { car . price = \"low\" ; } The indentation should always be made with a tab . For every hierarchy step one tab has to be added. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; if ( car . weight >= 1000 ) { car . type = \"Truck\" ; } } else { car . price = \"low\" ; } Comments If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. For commenting block // should be used. ATTENTION Inline comments should be used with caution, because they can cause chaotic code. Example DON'T // divides up two double values double division ( double dividend , double divisor ) { // this is the result variable double div ; // the result is calculated here: div = dividend / divisor ; // here the result is given back return div ; } More to come here...","title":"C++"},{"location":"tutorials/cpp-coding-style/#coding-style","text":"Next to consistency as a main aspect of good code, the second most important aspect is a certain style which the average c++ programmer is capable to read and understand properly. Therefore the following documents states the essential naming conventions. Here is a link for a more detailed dive into `c++ core guidelines' Style guide by the Barr Group: Style Guide","title":"Coding Style"},{"location":"tutorials/cpp-coding-style/#naming-conventions","text":"","title":"Naming conventions"},{"location":"tutorials/cpp-coding-style/#variables","text":"The name of a variable should be as accurate as possible and as short as possible at the same time. Example: // don't int x ; x = 10 + 5 ; // do int sum sum = 10 + 5 ; A variable can be used in two different scenarios. Global/Local variables Global/Local variables should be defined in a snake_case style. Example: int global_variable ; Private variables Private variables should be defined the same way as global variables. The main difference for private variables is a defined prefix _ . Example: int _private_variable ;","title":"Variables"},{"location":"tutorials/cpp-coding-style/#constants-preprocessor-values","text":"Constants are expression with a fixed value. They are defined with the key `const. The naming convention for constants and preprocessor values prescribes that all letters are upper case letters with snake case subdivision Example: const int PI_VALUE = 3.14159 ;","title":"Constants &amp; Preprocessor Values"},{"location":"tutorials/cpp-coding-style/#functions","text":"A function is a block of code which runs when it's called. Data in form of parameters can be passed into a function. Functions can be written as non-returning and returning type. Functions should start with a lower case letter. The following word should be upper case . This method is called camelCase Example: void exampleFunktion () { // do some stuff }","title":"Functions"},{"location":"tutorials/cpp-coding-style/#classes-types-template-parameters","text":"C++ is a object-oriented programming language. Therefore it's all about creating objects which contain both data and functions for a certain task. In the example picture shown above, there is the class car defined, which has certain methods and attributes . This class can be used to create different objects which share the same set* of properties with different values. A class should be defined with all upper case (PascalCase) notation. Example: class Car { public : string brand ; int max_speed ; int power ; Car ( string ini_brand , int ini_speed , ini_power ) { brand = ini_brand ; max_speed = ini_speed ; power = ini_power ; } private : int _current_speed ; }; void GeneralCar::setSpeed ( int new_speed ) { _current_speed = new_speed ; } int main () { // declaration of two objects Car car1 ( \"Auto1\" , 200 , 100 ); Car car2 ( \"Auto2\" , 300 , 200 ); //setting the speed car1 . setSpeed ( 250 ); return 0 ; }","title":"Classes (Types, Template parameters)"},{"location":"tutorials/cpp-coding-style/#braces","text":"In order to get a clear structure the following braces scheme should be taking into account when programming. Every left brace ( { ) should be appear by itself on the line below it the block it opens. The corresponding right brace ( } ) should be placed by itself in the same position th appropriate number of lines later in the file. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; } else { car . price = \"low\" ; } The indentation should always be made with a tab . For every hierarchy step one tab has to be added. Example if ( car . speed == \"fast\" ) { car . price = \"high\" ; if ( car . weight >= 1000 ) { car . type = \"Truck\" ; } } else { car . price = \"low\" ; }","title":"Braces"},{"location":"tutorials/cpp-coding-style/#comments","text":"If the section of code is not clearly understandable there should be a short description of the current function in form of a comment. For commenting block // should be used. ATTENTION Inline comments should be used with caution, because they can cause chaotic code. Example DON'T // divides up two double values double division ( double dividend , double divisor ) { // this is the result variable double div ; // the result is calculated here: div = dividend / divisor ; // here the result is given back return div ; } More to come here...","title":"Comments"},{"location":"tutorials/git-commit-style/","text":"Branching System Git in a nutshell! What is Git? Git is a Version Control System (VCS). With the utilization of Git the entire history of the project can be tracked. This means the VCS automatically tracks every minute change in the project and allows users to revert back to a previous version no matter how often the file got changed. Here is an Example GIT TREE The other main advantage is that Git allows people to work together seamlessly. With Git people can contribute onto the same project without disturbing each other's files. This allows team-members to work on different features within the project at the same time and easily merge changes together later on 1 . Basic terminology 1 Repository A Repository is a folder that is watched by Git. Here all file changes will be detected. A \"Repo\" builds up as the frame of everything Branch A Branch is an independent line of development. There will exists multiple branches within a Repo. Every Branch is its own working directory. Clone A clone is a simply copy of a repository that's downloaded and stored on the own computer. Commit A commit is a set of one ore more changes to a file (or a set of files). Every chang will create an unique ID (\"hash\") which helps keeping track of the history of the project. Master That's the default (initial) development branch. It's automatically created at the birth of the Repo. The master branch is usually used for merging the final result of a project together. For a more in-depth look have a look at the website: codeburst.io Basic Commands There are some basic commands that should be mastered right away when working with git . Clone With this command a repository with the suited link is cloned into the . directory. git clone <link> . Branch With this command all local pulled branches will be displayed in the shell. The current branch is marked in a certain color. git branch Switch Branches In order to switch different branches this command can be used git checkout <desired branch> Add This command is need to add new changes to a commit from the . directory. git add . Commit With this command the changes are ported to the repository and added to the version control git commit -m \"SUITABLE MESSAGE\" Push With this command the changes are uploaded to the remote repository git push Pull With this command new changes are downloaded to the local repository git pull Commit Style In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. f.e git commit -m \"ADD function XY()\" FIX Used for minor changes, bugfixes of an already existing part of the code. f.e git commit -m \"FIX functionality of XY\" REF Written short for: REFACTOR. Is used when there is a major change in multiple code-segments and the structure of the code is reworked. f.e git commit -m \"UPDATE setup of analog sensors\" Creating Pull Requests In order to keep the master branch clean and functioning the prototyping repository has a branch protection rule . When someone wants to merge code onto the master branche a pull request has to be made. The pull request informs the admin of the repository to have a look over the code in order to approve if this its functioning and good code which can be merged without hesitation. In order to understand how to create a pull request have a look here source: https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f \u21a9 \u21a9","title":"Git"},{"location":"tutorials/git-commit-style/#branching-system","text":"","title":"Branching System"},{"location":"tutorials/git-commit-style/#git-in-a-nutshell","text":"","title":"Git in a nutshell!"},{"location":"tutorials/git-commit-style/#what-is-git","text":"Git is a Version Control System (VCS). With the utilization of Git the entire history of the project can be tracked. This means the VCS automatically tracks every minute change in the project and allows users to revert back to a previous version no matter how often the file got changed. Here is an Example GIT TREE The other main advantage is that Git allows people to work together seamlessly. With Git people can contribute onto the same project without disturbing each other's files. This allows team-members to work on different features within the project at the same time and easily merge changes together later on 1 .","title":"What is Git?"},{"location":"tutorials/git-commit-style/#basic-terminology1","text":"Repository A Repository is a folder that is watched by Git. Here all file changes will be detected. A \"Repo\" builds up as the frame of everything Branch A Branch is an independent line of development. There will exists multiple branches within a Repo. Every Branch is its own working directory. Clone A clone is a simply copy of a repository that's downloaded and stored on the own computer. Commit A commit is a set of one ore more changes to a file (or a set of files). Every chang will create an unique ID (\"hash\") which helps keeping track of the history of the project. Master That's the default (initial) development branch. It's automatically created at the birth of the Repo. The master branch is usually used for merging the final result of a project together. For a more in-depth look have a look at the website: codeburst.io","title":"Basic terminology1"},{"location":"tutorials/git-commit-style/#basic-commands","text":"There are some basic commands that should be mastered right away when working with git . Clone With this command a repository with the suited link is cloned into the . directory. git clone <link> . Branch With this command all local pulled branches will be displayed in the shell. The current branch is marked in a certain color. git branch Switch Branches In order to switch different branches this command can be used git checkout <desired branch> Add This command is need to add new changes to a commit from the . directory. git add . Commit With this command the changes are ported to the repository and added to the version control git commit -m \"SUITABLE MESSAGE\" Push With this command the changes are uploaded to the remote repository git push Pull With this command new changes are downloaded to the local repository git pull","title":"Basic Commands"},{"location":"tutorials/git-commit-style/#commit-style","text":"In order to achieve a uniform naming for commit messages the following commit style should be used when creating a new commit message. Keyword Description ADD Is used if there is a new change in the code. f.e git commit -m \"ADD function XY()\" FIX Used for minor changes, bugfixes of an already existing part of the code. f.e git commit -m \"FIX functionality of XY\" REF Written short for: REFACTOR. Is used when there is a major change in multiple code-segments and the structure of the code is reworked. f.e git commit -m \"UPDATE setup of analog sensors\"","title":"Commit Style"},{"location":"tutorials/git-commit-style/#creating-pull-requests","text":"In order to keep the master branch clean and functioning the prototyping repository has a branch protection rule . When someone wants to merge code onto the master branche a pull request has to be made. The pull request informs the admin of the repository to have a look over the code in order to approve if this its functioning and good code which can be merged without hesitation. In order to understand how to create a pull request have a look here source: https://codeburst.io/git-and-github-in-a-nutshell-b0a3cc06458f \u21a9 \u21a9","title":"Creating Pull Requests"},{"location":"tutorials/prototyping-guide/","text":"Prototyping Guide In order to create a good documentation the general setup of the file-tree has to be understood. Therefor the file-tree can be divided into two parts: PlatformIO Part Documentation Part PlatformIO The programming part is done in the tree part /src/ . Here the main.cpp file is stored on the top level. For every new category there should be a appropriate sub-file-tree where corresponding topics can be collected. As a starting example the directories /src/arduino-hardware/ , /src/arduino-iot-cloud/ and /src/aws/ have been created. For every new part of prototyping a suited folder in the example directories has to be created, eg. /src/aws/mqtt/ . All relevant files can be saved here ( .cpp , .hpp etc...). Documentation The documentation part ist done in the tree part /docs/src/ Here a mirror directory of the /src/ is created. That simplifies the overall visual structure. In the corresponding sub-folder , eg. /docs/src/aws/mqtt the necessary MARKDOWN .md needs to be stored. The Markdown file is used to record all necessary information about the finished prototyping.","title":"Prototyping Guide"},{"location":"tutorials/prototyping-guide/#prototyping-guide","text":"In order to create a good documentation the general setup of the file-tree has to be understood. Therefor the file-tree can be divided into two parts: PlatformIO Part Documentation Part","title":"Prototyping Guide"},{"location":"tutorials/prototyping-guide/#platformio","text":"The programming part is done in the tree part /src/ . Here the main.cpp file is stored on the top level. For every new category there should be a appropriate sub-file-tree where corresponding topics can be collected. As a starting example the directories /src/arduino-hardware/ , /src/arduino-iot-cloud/ and /src/aws/ have been created. For every new part of prototyping a suited folder in the example directories has to be created, eg. /src/aws/mqtt/ . All relevant files can be saved here ( .cpp , .hpp etc...).","title":"PlatformIO"},{"location":"tutorials/prototyping-guide/#documentation","text":"The documentation part ist done in the tree part /docs/src/ Here a mirror directory of the /src/ is created. That simplifies the overall visual structure. In the corresponding sub-folder , eg. /docs/src/aws/mqtt the necessary MARKDOWN .md needs to be stored. The Markdown file is used to record all necessary information about the finished prototyping.","title":"Documentation"}]}